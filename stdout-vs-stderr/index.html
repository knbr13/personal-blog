<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <meta property="og:type" content="website" />
      <meta property="og:url" content="https://blog.orhun.dev"/>
      
      <meta property="og:title" content="Why stdout is faster than stderr? - Orhun&#x27;s Blog" />
      
      <meta property="og:image" content="https://blog.orhun.dev/crow.png" />
      
      <meta name="description" content="FOSS • Linux • Programming" />
      <meta property="og:description" content="FOSS • Linux • Programming"/>
      

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

      <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
      <link rel="manifest" href="/favicon/site.webmanifest">

      <script async src="https://umami.orhun.dev/script.js" data-website-id="56ca5ca7-ba9f-416e-8bee-a132c155d56b"></script>

      <link rel="stylesheet" href="https://unpkg.com/applause-button/dist/applause-button.css" />
      <script src="https://unpkg.com/applause-button/dist/applause-button.js"></script>

      
      <title>Why stdout is faster than stderr? - Orhun&#x27;s Blog</title>
      

      
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.orhun.dev/rss.xml">
      

      
          <link rel="stylesheet" href="https://blog.orhun.dev/site.css">
      

      
      
    </head>

    <body class="hack dark main container">
        
    
        
                
                    <header>
                        <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                        
                            <a itemprop="url"
                               class=""
                               href="https://blog.orhun.dev">
                                <span itemprop="name">Home</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://blog.orhun.dev/categories">
                                <span itemprop="name">Categories</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://github.com/orhun/personal-blog">
                                <span itemprop="name">Source</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://github.com/orhun">
                                <span itemprop="name">GitHub</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://donate.orhun.dev">
                                <span itemprop="name">Donate</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://blog.orhun.dev/rss.xml">
                                <span itemprop="name">RSS</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https://orhun.dev">
                                <span itemprop="name">About</span></a>
                        
                        </nav>
                    </header>
                
            
    

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">Why stdout is faster than stderr?</h1>
        <span class="muted">
    <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>31 minute read</span>
    <svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2024-01-10
</span>
    </header>
    <div itemprop="articleBody">
      <p>I recently realized stdout is much faster than stderr for Rust. Here are my findings after diving deep into this rabbit hole.</p>
<span id="continue-reading"></span><center>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/rabbit.png" alt="rabbit" /></p>
</center>
<p>I have been using the terminal (i.e. command-line) for most of my day-to-day things for a while now. I was always fascinated by the fact that how quick and convenient the command-line might be and that's why I'm a proponent of using CLI (command-line) or TUI (terminal user interface) applications over GUI (graphical user interface) applications, when it is possible. On top of my already existing preference, I started to wholeheartedly believe that the <g>terminal is the future</g> after seeing the recent developments in the terminal user experience with tools like <a href="https://zellij.dev/">Zellij</a> and GPU-powered terminal emulators such as <a href="https://alacritty.org/">Alacritty</a>/<a href="https://wezfurlong.org/wezterm/">Wezterm</a>/<a href="https://raphamorim.io/rio/">Rio</a>. When this huge potential is combined with a robust systems programming language such as <a href="https://www.rust-lang.org/">Rust</a>, the result is often times a very smooth terminal and development experience which I think every developer appreciates when it comes to effectiveness, speed and safety.</p>
<p>That is most likely why I was drawn into building terminal user interface applications with Rust in the first place. When I built my first ever Rust/TUI project, <a href="https://github.com/orhun/kmon">kmon</a>, I was surprised by how the limits of a simple thing such as a terminal can be pushed to build applications which gets you addicted to using terminals even more. Couple of years later, I'm one of the maintainers of <a href="https://ratatui.rs/">Ratatui</a> which is a Rust library for cooking up TUIs and I'm blessed to be one of the core team members which revived the unmaintained <a href="https://github.com/fdehau/tui-rs">tui-rs</a> library as Ratatui last year.</p>
<p>When you take all of this into account, as a daily terminal user and a command-line developer, I'm tackling new terminal related issues every day. Sometimes I come across really interesting questions and problems. As you might expect, this blog post is the fruit of one of those questions.</p>
<blockquote>
<p><glitched>Why stdout is faster than stderr?</glitched></p>
</blockquote>
<p>Okay, now let's take a step back and try to understand the question first. We need to grasp some concepts about UNIX before everything.</p>
<details>
<summary><b>Table of Contents</b></summary>
<ul>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#i-o-streams">I/O Streams</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#tui-applications-and-i-o">TUI Applications and I/O</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#measuring-fps">Measuring FPS</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#profiling">Profiling</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#testing-the-buffered-theory">Testing the buffered theory</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#experimenting-with-buffered-writes">Experimenting with buffered writes</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#experimenting-with-raw-writes">Experimenting with raw writes</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#making-stdout-faster">Making stdout faster</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#findings">Findings</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#other-languages">Other Languages</a></li>
<li><a href="https://blog.orhun.dev/stdout-vs-stderr/#conclusion">Conclusion</a></li>
</ul>
</details>
<hr />
<h2 id="i-o-streams"><g>I/O Streams</g></h2>
<p><a href="https://en.wikipedia.org/wiki/Unix">UNIX</a> operating system brought many groundbreaking advances into the world of computers and undoubtedly one of them was the standard streams. According to UNIX, every process has three streams opened for it when it starts up:</p>
<p>0. Standard Input (<code>stdin</code>): for reading input.<br />
1. Standard Output (<code>stdout</code>): for writing conventional output.<br />
2. Standard Error (<code>stderr</code>): for printing diagnostic or error messages.</p>
<p>Here is an oversimplified example to demonstrate these streams:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="background-color:#171717;color:#616161;"># read the value of foo from stdin
</span><span style="color:#cccccc;">$ read</span><span style="font-style:italic;color:#8aa6c1;"> -r</span><span style="color:#cccccc;"> foo
</span><span style="color:#cccccc;">test
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;"># print the value of foo to stdout
</span><span style="color:#cccccc;">$ echo </span><span style="color:#ffd700;">&quot;value of foo is &#39;$foo&#39;&quot;
</span><span style="color:#cccccc;">value of foo is </span><span style="color:#ffd700;">&#39;test&#39;
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;"># &quot;echoo&quot; command does not exist so an error message will be printed to stderr
</span><span style="color:#cccccc;">$ echoo </span><span style="color:#ffd700;">&quot;$foo&quot;
</span><span style="color:#cccccc;">bash: echoo: command not found
</span></code></pre>
<p>These I/O (input/output) streams are typically attached to the user's terminal via <a href="https://linux.die.net/man/4/tty">tty</a> (TeleTYpe) which can be described as an interface that enables access to the terminal.</p>
<p>As you might have heard multiple times, "everything is a file" according to the UNIX philosophy. This means that the I/O streams should also be a file and this is in fact true:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ file /dev/stdin /dev/stdout /dev/stderr
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">/dev/stdin:  symbolic link to /proc/self/fd/0
</span><span style="color:#cccccc;">/dev/stdout: symbolic link to /proc/self/fd/1
</span><span style="color:#cccccc;">/dev/stderr: symbolic link to /proc/self/fd/2
</span></code></pre>
<p>If you have realized, the file descriptor (unique identifier) of these <em>abstract</em> files are the same as the initial list given above (starts from 0).</p>
<q>
So if they are files, we should be able to read them right?
</q>
<p>Actually, no-</p>
<q>
*types quickly*
</q>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ cat /dev/stdout
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">
</span></code></pre>
<q>
Why nothing is happening?
</q>
<p>*sigh* It is because they are not real files, they are just file descriptors linked to TTY or PTY (i.e. emulated TTY AKA PseudoTeletYpe).</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ ls</span><span style="font-style:italic;color:#8aa6c1;"> -l</span><span style="color:#cccccc;"> /proc/self/fd/
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">lrwx------ - orhun  0 -</span><span>&gt;</span><span style="color:#cccccc;"> /dev/pts/20
</span><span style="color:#cccccc;">lrwx------ - orhun  1 -</span><span>&gt;</span><span style="color:#cccccc;"> /dev/pts/20
</span><span style="color:#cccccc;">lrwx------ - orhun  2 -</span><span>&gt;</span><span style="color:#cccccc;"> /dev/pts/20
</span></code></pre>
<p>As you can see, the standard streams are attached to PTYs (i.e. pseudo-terminals) under <code>/dev/pts</code>.</p>
<p><q>Wait, so <code>/dev/stdout</code> is a symlink to a file descriptor at <code>/proc/self/fd/1</code> and that file descriptor is a symlink to <code>/dev/pts/20</code>!? <br><br> What even is <code>/dev/pts/20</code> in this case?</q></p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ file /dev/pts/20
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">/dev/pts/20: character special (136/20)
</span></code></pre>
<p><q>bruh, what?</q></p>
<p>In Unix, character special files are files that access to I/O devices such as a NULL file (<code>/dev/null</code>) and file descriptors. In our case, <code>stdout</code> is a file descriptor (1) so it is a character special file. (The name "character special" actually comes from the fact that each character is handled individually.)</p>
<p>Each character special file has a device <em>major</em> number, which identifies the device type, and device <em>minor</em> number, which identifies a specific device of a given device type. So what you see on the right (136/20) means:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ rg </span><span style="color:#ffd700;">&#39;136&#39;</span><span style="color:#cccccc;"> /proc/devices
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">136 pts
</span></code></pre>
<ul>
<li>Major 136: a PTS device (<code>/dev/pts</code>)</li>
<li>Minor 20: device 20 (<code>/dev/pts/20</code>)</li>
</ul>
<p><q>Ok cool, but why am I not able to read from <code>/dev/stdout</code>?</q></p>
<p>Oh that, yes. When you try to read data from stdout, it keeps running because it's waiting for data to read from the file descriptor. So if you give it input, then you can read it back:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ cat /dev/stdout
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">foo </span><span style="background-color:#171717;color:#616161;"># input
</span><span style="color:#cccccc;">foo
</span><span style="color:#cccccc;">bar </span><span style="background-color:#171717;color:#616161;">#input
</span><span style="color:#cccccc;">bar
</span></code></pre>
<p>Now that we have a general understanding of I/O streams, we can jump to the real world examples and make progress towards answering our question.</p>
<hr />
<h2 id="tui-applications-and-i-o"><g>TUI Applications and I/O</g></h2>
<blockquote>
<p>The following section makes use of the <a href="https://www.rust-lang.org/">Rust programming language</a> but the overall concepts are generally appliable to any programming language - even HolyC.</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Text-based_user_interface">Terminal user interfaces</a> leverages the terminal by drawing widgets/components such as text inputs, spinners and styled text on it, similar to the traditional graphical user interfaces. The terminal is able to <em>render</em> such elements thanks to the custom handling of <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>. These ANSI <em>sequences</em> are used to control the cursor location, color and styling of the terminal.</p>
<p>So in order the create a terminal user interface, we need a <em>low-level library</em> for controlling both the terminal and I/O streams and also rendering the UI components. Usually, this two step process is split between different libraries for ease-of-use and the sake of single responsibility principle.</p>
<p>For example, while <a href="https://en.wikipedia.org/wiki/Ncurses">ncurses</a> (one of the oldest TUI libraries written in C) is taking care of the low-level interface to the terminal, <a href="https://invisible-island.net/cdk/">CDK</a> (curses development kit) provides a sets of widgets to build GUI-like applications in the terminal.</p>
<p>Similarly in the Rust ecosystem, the following libraries are the most preferred ones for this task today:</p>
<ul>
<li><a href="https://github.com/crossterm-rs/crossterm">crossterm</a>: pure-Rust cross-platform terminal manipulation library.</li>
<li><a href="https://github.com/ratatui-org/ratatui">ratatui</a>: lightweight library that provides a set of widgets and utilities - supports different backends including <code>crossterm</code>.</li>
</ul>
<p>So let's build a very simple TUI using these libraries:</p>
<details>
<summary><span class="glowy-code"><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/simple-tui.rs">simple-tui.rs</a></span> (<b>click here to expand</b>)</summary>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#!/</span><span style="color:#cccccc;">usr</span><span>/</span><span style="color:#cccccc;">bin</span><span>/</span><span style="color:#cccccc;">env rust</span><span>-</span><span style="color:#cccccc;">script
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">//! ```cargo
</span><span style="background-color:#171717;color:#616161;">//! [dependencies]
</span><span style="background-color:#171717;color:#616161;">//! crossterm = &quot;0.27.0&quot;
</span><span style="background-color:#171717;color:#616161;">//! ratatui = &quot;0.25.0&quot;
</span><span style="background-color:#171717;color:#616161;">//! ```
</span><span style="color:#cccccc;">
</span><span>use </span><span style="color:#cccccc;">std::io::{self, stdout};
</span><span style="color:#cccccc;">
</span><span>use </span><span style="color:#cccccc;">crossterm::{
</span><span style="color:#cccccc;">    event::{self, Event, KeyCode, KeyEventKind},
</span><span style="color:#cccccc;">    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
</span><span style="color:#cccccc;">    ExecutableCommand,
</span><span style="color:#cccccc;">};
</span><span>use </span><span style="color:#cccccc;">ratatui::{prelude::</span><span>*</span><span style="color:#cccccc;">, widgets::</span><span>*</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">/// Handle key events.
</span><span style="color:#80d500;">fn </span><span>handle_events</span><span style="color:#cccccc;">() -&gt; io::</span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;</span><span style="color:#80d500;">bool</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">if </span><span style="color:#cccccc;">event::poll(std::time::Duration::from_millis(</span><span style="color:#eddd5a;">50</span><span style="color:#cccccc;">))</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if let </span><span style="color:#cccccc;">Event::Key(key) </span><span>= </span><span style="color:#cccccc;">event::read()</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            </span><span style="background-color:#171717;color:#616161;">// Quit when &#39;q&#39; is pressed.
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">if</span><span style="color:#cccccc;"> key.kind </span><span>== </span><span style="color:#cccccc;">KeyEventKind::Press </span><span>&amp;&amp;</span><span style="color:#cccccc;"> key.code </span><span>== </span><span style="color:#cccccc;">KeyCode::Char(</span><span style="color:#ffd700;">&#39;q&#39;</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">return </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">true</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">false</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">/// Render the widgets.
</span><span style="color:#80d500;">fn </span><span>ui</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">frame</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">mut</span><span style="color:#cccccc;"> Frame) {
</span><span style="color:#cccccc;">    frame.</span><span style="color:#8aa6c1;">render_widget</span><span style="color:#cccccc;">(
</span><span style="color:#cccccc;">        Paragraph::new(</span><span style="color:#ffd700;">&quot;__QQ</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">(_)_</span><span style="font-weight:bold;color:#ff2837;">\&quot;</span><span style="color:#ffd700;">&gt;&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">alignment</span><span style="color:#cccccc;">(Alignment::Center)
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">block</span><span style="color:#cccccc;">(
</span><span style="color:#cccccc;">                Block::default()
</span><span style="color:#cccccc;">                    .</span><span style="color:#8aa6c1;">title</span><span style="color:#cccccc;">(</span><span style="color:#ffd700;">&quot;blog.orhun.dev&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">                    .</span><span style="color:#8aa6c1;">borders</span><span style="color:#cccccc;">(Borders::</span><span style="color:#66ccff;">ALL</span><span style="color:#cccccc;">),
</span><span style="color:#cccccc;">            ),
</span><span style="color:#cccccc;">        frame.</span><span style="color:#8aa6c1;">size</span><span style="color:#cccccc;">(),
</span><span style="color:#cccccc;">    );
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; io::</span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">enable_raw_mode</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">().</span><span style="color:#8aa6c1;">execute</span><span style="color:#cccccc;">(EnterAlternateScreen)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(</span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">()))</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> should_quit </span><span>= </span><span style="color:#80d500;">false</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">while </span><span>!</span><span style="color:#cccccc;">should_quit {
</span><span style="color:#cccccc;">        terminal.</span><span style="color:#8aa6c1;">draw</span><span style="color:#cccccc;">(ui)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        should_quit </span><span>= </span><span style="color:#8aa6c1;">handle_events</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">disable_raw_mode</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">().</span><span style="color:#8aa6c1;">execute</span><span style="color:#cccccc;">(LeaveAlternateScreen)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
</details>
<p>You can run this using <a href="https://github.com/fornwall/rust-script">rust-script</a> as follows:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ cargo install rust-script
</span><span style="background-color:#171717;color:#616161;"># [...]
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">$ chmod +x simple-tui.rs
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">$ ./simple-tui.rs
</span></code></pre>
<p>Depending on your terminal size, you will get a result similar to this:</p>
<pre style="background-color:#191919;color:#ffffff;"><code><span>┌blog.orhun.dev──────────────────────────┐
</span><span>│                  __QQ                  │
</span><span>│                 (_)_&quot;&gt;                 │
</span><span>│                                        │
</span><span>└────────────────────────────────────────┘
</span></code></pre>
<p><q>That's cool! How does that happen?</q></p>
<p>Let's break down the code into multiple steps to understand what's going on:</p>
<p><strong>1.</strong> Initializing the terminal</p>
<p>In the <code>main</code> function, we use <code>crossterm</code> to set up our terminal on <em>stdout</em> and tell <code>ratatui</code> to use the <code>crossterm</code> backend.</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::io::stdout;
</span><span>use </span><span style="color:#cccccc;">ratatui::{Terminal, backend::CrosstermBackend};
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">crossterm::terminal::enable_raw_mode()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">().</span><span style="color:#8aa6c1;">execute</span><span style="color:#cccccc;">(EnterAlternateScreen)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(</span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">()))</span><span>?</span><span style="color:#cccccc;">;
</span></code></pre>
<p><q>Raw mode and alternate screen?</q></p>
<p>Enabling <a href="https://docs.rs/crossterm/latest/crossterm/terminal/index.html#raw-mode">raw mode</a> means that we won't be using the default behavior of the terminal (no input handling and special keys) and we would like to have full control over it. We are also entering an alternative screen (i.e. new buffer) on the terminal since we don't want to lose our actual terminal/command-line and go back to it when 'q' is pressed.</p>
<p>Speaking of input handling, here is how we do it:</p>
<p><strong>2.</strong> Handling key events</p>
<p>We are simply <a href="https://docs.rs/crossterm/latest/crossterm/event/fn.poll.html">polling</a> events from <code>crossterm</code> in <code>handle_events</code> function and quit when 'q' is pressed:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">crossterm::event::{self, Event, KeyCode};
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">if </span><span style="color:#cccccc;">crossterm::event::poll(std::time::Duration::from_millis(</span><span style="color:#eddd5a;">50</span><span style="color:#cccccc;">))</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">if let </span><span style="color:#cccccc;">Event::Key(key) </span><span>= </span><span style="color:#cccccc;">event::read()</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if</span><span style="color:#cccccc;"> key.kind </span><span>== </span><span style="color:#cccccc;">KeyEventKind::Press </span><span>&amp;&amp;</span><span style="color:#cccccc;"> key.code </span><span>== </span><span style="color:#cccccc;">KeyCode::Char(</span><span style="color:#ffd700;">&#39;q&#39;</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">return </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">true</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span></code></pre>
<p><strong>3.</strong> Rendering widgets</p>
<p>And lastly, this is where <code>ratatui</code> shines:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">ratatui::{prelude::</span><span>*</span><span style="color:#cccccc;">, widgets::</span><span>*</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">frame.</span><span style="color:#8aa6c1;">render_widget</span><span style="color:#cccccc;">(
</span><span style="color:#cccccc;">    Paragraph::new(</span><span style="color:#ffd700;">&quot;__QQ</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">(_)_</span><span style="font-weight:bold;color:#ff2837;">\&quot;</span><span style="color:#ffd700;">&gt;&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">        .</span><span style="color:#8aa6c1;">alignment</span><span style="color:#cccccc;">(Alignment::Center)
</span><span style="color:#cccccc;">        .</span><span style="color:#8aa6c1;">block</span><span style="color:#cccccc;">(
</span><span style="color:#cccccc;">            Block::default()
</span><span style="color:#cccccc;">                .</span><span style="color:#8aa6c1;">title</span><span style="color:#cccccc;">(</span><span style="color:#ffd700;">&quot;blog.orhun.dev&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">                .</span><span style="color:#8aa6c1;">borders</span><span style="color:#cccccc;">(Borders::</span><span style="color:#66ccff;">ALL</span><span style="color:#cccccc;">),
</span><span style="color:#cccccc;">        ),
</span><span style="color:#cccccc;">    frame.</span><span style="color:#8aa6c1;">size</span><span style="color:#cccccc;">(),
</span><span style="color:#cccccc;">);
</span></code></pre>
<p>Here, we are creating two widgets:</p>
<ul>
<li><a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Paragraph.html">Paragraph</a>: contains a centered text</li>
<li><a href="https://docs.rs/ratatui/latest/ratatui/widgets/block/struct.Block.html">Block</a>: wraps the paragraph with a title</li>
</ul>
<p><code>ratatui</code> provides many other widgets and makes it surprisingly easy to build complex interfaces. Also, as you can see from the example, it is actually easy to center a <strike>div</strike> text.</p>
<p>Going back to our original topic, if you take a look at the <code>main</code> function again, this all happens on <em>stdout</em>:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::io::stdout;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(</span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">()))</span><span>?</span><span style="color:#cccccc;">;
</span></code></pre>
<p>Obviously, we can try changing all the references of <code>std::io::stdout</code> to <code>std::io::stderr</code> and try running again.</p>
<pre data-lang="diff" style="background-color:#191919;color:#ffffff;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="background-color:#420e09;color:#f8f8f8;">-let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stdout()))?;
</span><span style="background-color:#253b22;color:#f8f8f8;">+let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
</span></code></pre>
<p><q>... then what happens?</q></p>
<p>Well, nothing changes visually and we can't tell a difference. It is the same result.</p>
<p>Or is it?</p>
<hr />
<h2 id="measuring-fps"><g>Measuring FPS</g></h2>
<p>We need a way of measuring the performance of the rendered TUI and see the difference between using stdout and stderr. For that, I came up with a FPS (frames per second) counter application along with some monochrome colors for visualization (based on <code>ratatui</code>'s <a href="https://github.com/ratatui-org/ratatui/blob/main/examples/colors_rgb.rs">colors_rgb</a> template).</p>
<details>
<summary><span class="glowy-code"><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/stdout-vs-stderr.rs">stdout-vs-stderr.rs</a></span> (<b>click here to expand</b>)</summary>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#!/</span><span style="color:#cccccc;">usr</span><span>/</span><span style="color:#cccccc;">bin</span><span>/</span><span style="color:#cccccc;">env rust</span><span>-</span><span style="color:#cccccc;">script
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">//! ```cargo
</span><span style="background-color:#171717;color:#616161;">//! [dependencies]
</span><span style="background-color:#171717;color:#616161;">//! anyhow = &quot;1.0.76&quot;
</span><span style="background-color:#171717;color:#616161;">//! crossterm = &quot;0.27.0&quot;
</span><span style="background-color:#171717;color:#616161;">//! palette = &quot;0.7.3&quot;
</span><span style="background-color:#171717;color:#616161;">//! rand = &quot;0.8.5&quot;
</span><span style="background-color:#171717;color:#616161;">//! ratatui = &quot;0.25.0&quot;
</span><span style="background-color:#171717;color:#616161;">//! ```
</span><span style="background-color:#171717;color:#616161;">//!
</span><span style="color:#cccccc;">
</span><span>use </span><span style="color:#cccccc;">anyhow::Result;
</span><span>use </span><span style="color:#cccccc;">std::{
</span><span style="color:#cccccc;">    fmt,
</span><span style="color:#cccccc;">    io::{stderr, stdout, Write},
</span><span style="color:#cccccc;">    time::{Duration, Instant},
</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span>use </span><span style="color:#cccccc;">crossterm::{
</span><span style="color:#cccccc;">    event::{self, Event, KeyCode, KeyEventKind},
</span><span style="color:#cccccc;">    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
</span><span style="color:#cccccc;">    ExecutableCommand,
</span><span style="color:#cccccc;">};
</span><span>use </span><span style="color:#cccccc;">palette::{convert::FromColorUnclamped, Hsv, Srgb};
</span><span>use </span><span style="color:#cccccc;">ratatui::{prelude::</span><span>*</span><span style="color:#cccccc;">, widgets::</span><span>*</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">#[derive(Copy, Clone, Debug, Default)]
</span><span style="color:#80d500;">enum </span><span style="color:#cccccc;">IoStream {
</span><span style="color:#cccccc;">    #[default]
</span><span style="color:#cccccc;">    Stdout,
</span><span style="color:#cccccc;">    Stderr,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">fmt::Display </span><span>for </span><span style="color:#cccccc;">IoStream {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>fmt</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">f</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="color:#cccccc;">fmt::Formatter&lt;&#39;</span><span>_</span><span style="color:#cccccc;">&gt;) -&gt; fmt::Result {
</span><span style="color:#cccccc;">        write!(f, </span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, format!(</span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{:?}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, self).</span><span style="color:#8aa6c1;">to_lowercase</span><span style="color:#cccccc;">())
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">IoStream {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>as_stream</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">) -&gt; </span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">&lt;dyn Write&gt; {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">match </span><span style="color:#cccccc;">self {
</span><span style="color:#cccccc;">            IoStream::Stdout </span><span>=&gt; </span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">::new(</span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">()),
</span><span style="color:#cccccc;">            IoStream::Stderr </span><span>=&gt; </span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">::new(</span><span style="color:#8aa6c1;">stderr</span><span style="color:#cccccc;">()),
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">#[derive(Debug)]
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">Fps {
</span><span style="color:#cccccc;">    frame_count: </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">    last_instant: Instant,
</span><span style="color:#cccccc;">    fps: </span><span style="color:#8aa6c1;">Option</span><span style="color:#cccccc;">&lt;</span><span style="color:#80d500;">f32</span><span style="color:#cccccc;">&gt;,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">Default </span><span>for </span><span style="color:#cccccc;">Fps {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>default</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#80d500;">Self </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">Self </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            frame_count: </span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">            last_instant: Instant::now(),
</span><span style="color:#cccccc;">            fps: </span><span style="color:#8aa6c1;">None</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">Fps {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>tick</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">        self.frame_count </span><span>+= </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> elapsed </span><span>= </span><span style="color:#cccccc;">self.last_instant.</span><span style="color:#8aa6c1;">elapsed</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">        </span><span style="background-color:#171717;color:#616161;">// update the fps every second, but only if we&#39;ve rendered at least 2 frames (to avoid
</span><span style="color:#cccccc;">        </span><span style="background-color:#171717;color:#616161;">// noise in the fps calculation)
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if</span><span style="color:#cccccc;"> elapsed </span><span>&gt; </span><span style="color:#cccccc;">Duration::from_secs(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">) </span><span>&amp;&amp; </span><span style="color:#cccccc;">self.frame_count </span><span>&gt; </span><span style="color:#eddd5a;">2 </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            self.fps </span><span>= </span><span style="color:#8aa6c1;">Some</span><span style="color:#cccccc;">(self.frame_count </span><span>as </span><span style="color:#80d500;">f32 </span><span>/</span><span style="color:#cccccc;"> elapsed.</span><span style="color:#8aa6c1;">as_secs_f32</span><span style="color:#cccccc;">());
</span><span style="color:#cccccc;">            self.frame_count </span><span>= </span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">            self.last_instant </span><span>= </span><span style="color:#cccccc;">Instant::now();
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">FpsWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    fps: </span><span>&amp;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;"> Fps,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl</span><span style="color:#cccccc;">&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; Widget </span><span>for </span><span style="color:#cccccc;">FpsWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>render</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">area</span><span style="color:#cccccc;">: Rect, </span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">mut</span><span style="color:#cccccc;"> Buffer) {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if let </span><span style="color:#8aa6c1;">Some</span><span style="color:#cccccc;">(fps) </span><span>= </span><span style="color:#cccccc;">self.fps.fps {
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> text </span><span>= </span><span style="color:#cccccc;">format!(</span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{:.1}</span><span style="color:#ffd700;"> fps&quot;</span><span style="color:#cccccc;">, fps);
</span><span style="color:#cccccc;">            Paragraph::new(text).</span><span style="color:#8aa6c1;">render</span><span style="color:#cccccc;">(area, buf);
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">RgbColorsWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">/// the colors to render - should be double the height of the area
</span><span style="color:#cccccc;">    colors: </span><span>&amp;</span><span style="color:#80d500;">&#39;a </span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;</span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;Color&gt;&gt;,
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">/// the number of elapsed frames that have passed - used to animate the colors
</span><span style="color:#cccccc;">    frame_count: </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">Widget </span><span>for </span><span style="color:#cccccc;">RgbColorsWidget&lt;&#39;</span><span>_</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>render</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">area</span><span style="color:#cccccc;">: Rect, </span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">mut</span><span style="color:#cccccc;"> Buffer) {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> colors </span><span>= </span><span style="color:#cccccc;">self.colors;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">for </span><span style="color:#cccccc;">(xi, x) </span><span>in </span><span style="color:#cccccc;">(area.</span><span style="color:#8aa6c1;">left</span><span style="color:#cccccc;">()</span><span>..</span><span style="color:#cccccc;">area.</span><span style="color:#8aa6c1;">right</span><span style="color:#cccccc;">()).</span><span style="color:#8aa6c1;">enumerate</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">            </span><span style="background-color:#171717;color:#616161;">// animate the colors by shifting the x index by the frame number
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> xi </span><span>= </span><span style="color:#cccccc;">(xi </span><span>+ </span><span style="color:#cccccc;">self.frame_count) </span><span>% </span><span style="color:#cccccc;">(area.width </span><span>as </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">for </span><span style="color:#cccccc;">(yi, y) </span><span>in </span><span style="color:#cccccc;">(area.</span><span style="color:#8aa6c1;">top</span><span style="color:#cccccc;">()</span><span>..</span><span style="color:#cccccc;">area.</span><span style="color:#8aa6c1;">bottom</span><span style="color:#cccccc;">()).</span><span style="color:#8aa6c1;">enumerate</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> fg </span><span>=</span><span style="color:#cccccc;"> colors[yi </span><span>* </span><span style="color:#eddd5a;">2</span><span style="color:#cccccc;">][xi];
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> bg </span><span>=</span><span style="color:#cccccc;"> colors[yi </span><span>* </span><span style="color:#eddd5a;">2 </span><span>+ </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">][xi];
</span><span style="color:#cccccc;">                buf.</span><span style="color:#8aa6c1;">get_mut</span><span style="color:#cccccc;">(x, y).</span><span style="color:#8aa6c1;">set_char</span><span style="color:#cccccc;">(</span><span style="color:#ffd700;">&#39;▀&#39;</span><span style="color:#cccccc;">).</span><span style="color:#8aa6c1;">set_fg</span><span style="color:#cccccc;">(fg).</span><span style="color:#8aa6c1;">set_bg</span><span style="color:#cccccc;">(bg);
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">AppWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    title: Paragraph&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt;,
</span><span style="color:#cccccc;">    fps_widget: FpsWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt;,
</span><span style="color:#cccccc;">    rgb_colors_widget: RgbColorsWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt;,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl</span><span style="color:#cccccc;">&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; AppWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>new</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">app</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;"> App) -&gt; </span><span style="color:#80d500;">Self </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> title </span><span>= </span><span style="color:#cccccc;">Paragraph::new(vec![Line::styled(
</span><span style="color:#cccccc;">            app.current_stream.</span><span style="color:#8aa6c1;">to_string</span><span style="color:#cccccc;">(),
</span><span style="color:#cccccc;">            Style::new().</span><span style="color:#8aa6c1;">bold</span><span style="color:#cccccc;">(),
</span><span style="color:#cccccc;">        )])
</span><span style="color:#cccccc;">        .</span><span style="color:#8aa6c1;">alignment</span><span style="color:#cccccc;">(Alignment::Center);
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">Self </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            title,
</span><span style="color:#cccccc;">            fps_widget: FpsWidget { fps: </span><span>&amp;</span><span style="color:#cccccc;">app.fps },
</span><span style="color:#cccccc;">            rgb_colors_widget: RgbColorsWidget {
</span><span style="color:#cccccc;">                colors: </span><span>&amp;</span><span style="color:#cccccc;">app.colors,
</span><span style="color:#cccccc;">                frame_count: app.frame_count,
</span><span style="color:#cccccc;">            },
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">Widget </span><span>for </span><span style="color:#cccccc;">AppWidget&lt;&#39;</span><span>_</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>render</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">area</span><span style="color:#cccccc;">: Rect, </span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">mut</span><span style="color:#cccccc;"> Buffer) {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> main_layout </span><span>= </span><span style="color:#cccccc;">Layout::default()
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">direction</span><span style="color:#cccccc;">(Direction::Vertical)
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">constraints</span><span style="color:#cccccc;">([Constraint::Length(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">), Constraint::Min(</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">)])
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">split</span><span style="color:#cccccc;">(area);
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> title_layout </span><span>= </span><span style="color:#cccccc;">Layout::default()
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">direction</span><span style="color:#cccccc;">(Direction::Horizontal)
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">constraints</span><span style="color:#cccccc;">([Constraint::Min(</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">), Constraint::Length(</span><span style="color:#eddd5a;">8</span><span style="color:#cccccc;">)])
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">split</span><span style="color:#cccccc;">(main_layout[</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">]);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">        self.title.</span><span style="color:#8aa6c1;">render</span><span style="color:#cccccc;">(title_layout[</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">], buf);
</span><span style="color:#cccccc;">        self.fps_widget.</span><span style="color:#8aa6c1;">render</span><span style="color:#cccccc;">(title_layout[</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">], buf);
</span><span style="color:#cccccc;">        self.rgb_colors_widget.</span><span style="color:#8aa6c1;">render</span><span style="color:#cccccc;">(main_layout[</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">], buf);
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">#[derive(Debug, Default)]
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">App {
</span><span style="color:#cccccc;">    should_quit: </span><span style="color:#80d500;">bool</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">    switch_stream: </span><span style="color:#80d500;">bool</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">    current_stream: IoStream,
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// a 2D vector of the colors to render
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// calculated when the size changes as this is expensive to calculate every frame
</span><span style="color:#cccccc;">    colors: </span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;</span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;Color&gt;&gt;,
</span><span style="color:#cccccc;">    last_size: Rect,
</span><span style="color:#cccccc;">    fps: Fps,
</span><span style="color:#cccccc;">    frame_count: </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">App {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">pub fn </span><span>run</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">io_stream</span><span style="color:#cccccc;">: IoStream) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;</span><span style="color:#80d500;">bool</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#8aa6c1;">init_terminal</span><span style="color:#cccccc;">(io_stream.</span><span style="color:#8aa6c1;">as_stream</span><span style="color:#cccccc;">())</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> app </span><span>=</span><span style="color:#cccccc;"> App {
</span><span style="color:#cccccc;">            current_stream: io_stream,
</span><span style="color:#cccccc;">            </span><span>..</span><span style="color:#8aa6c1;">Default</span><span style="color:#cccccc;">::default()
</span><span style="color:#cccccc;">        };
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">while </span><span>!</span><span style="color:#cccccc;">app.should_quit </span><span>&amp;&amp; !</span><span style="color:#cccccc;">app.switch_stream {
</span><span style="color:#cccccc;">            app.</span><span style="color:#8aa6c1;">tick</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">            terminal.</span><span style="color:#8aa6c1;">draw</span><span style="color:#cccccc;">(|</span><span style="font-style:italic;color:#8aa6c1;">frame</span><span style="color:#cccccc;">| {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> size </span><span>=</span><span style="color:#cccccc;"> frame.</span><span style="color:#8aa6c1;">size</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">                app.</span><span style="color:#8aa6c1;">setup_colors</span><span style="color:#cccccc;">(size);
</span><span style="color:#cccccc;">                frame.</span><span style="color:#8aa6c1;">render_widget</span><span style="color:#cccccc;">(AppWidget::new(</span><span>&amp;</span><span style="color:#cccccc;">app), size);
</span><span style="color:#cccccc;">            })</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">            app.</span><span style="color:#8aa6c1;">handle_events</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">        </span><span style="color:#8aa6c1;">restore_terminal</span><span style="color:#cccccc;">(io_stream.</span><span style="color:#8aa6c1;">as_stream</span><span style="color:#cccccc;">())</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(app.should_quit)
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>tick</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">        self.frame_count </span><span>+= </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        self.fps.</span><span style="color:#8aa6c1;">tick</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>handle_events</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if </span><span style="color:#cccccc;">event::poll(Duration::from_secs_f32(</span><span style="color:#eddd5a;">1.0 </span><span>/ </span><span style="color:#eddd5a;">60.0</span><span style="color:#cccccc;">))</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">if let </span><span style="color:#cccccc;">Event::Key(key) </span><span>= </span><span style="color:#cccccc;">event::read()</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">if</span><span style="color:#cccccc;"> key.kind </span><span>== </span><span style="color:#cccccc;">KeyEventKind::Press </span><span>&amp;&amp;</span><span style="color:#cccccc;"> key.code </span><span>== </span><span style="color:#cccccc;">KeyCode::Char(</span><span style="color:#ffd700;">&#39;q&#39;</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">                    self.should_quit </span><span>= </span><span style="color:#80d500;">true</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">                }
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">if</span><span style="color:#cccccc;"> key.kind </span><span>== </span><span style="color:#cccccc;">KeyEventKind::Press </span><span>&amp;&amp;</span><span style="color:#cccccc;"> key.code </span><span>== </span><span style="color:#cccccc;">KeyCode::Char(</span><span style="color:#ffd700;">&#39; &#39;</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">                    self.switch_stream </span><span>= </span><span style="color:#80d500;">true</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">                };
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">        </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>setup_colors</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">size</span><span style="color:#cccccc;">: Rect) {
</span><span style="color:#cccccc;">        </span><span style="background-color:#171717;color:#616161;">// only update the colors if the size has changed since the last time we rendered
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if </span><span style="color:#cccccc;">self.last_size.width </span><span>==</span><span style="color:#cccccc;"> size.width </span><span>&amp;&amp; </span><span style="color:#cccccc;">self.last_size.height </span><span>==</span><span style="color:#cccccc;"> size.height {
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">return</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">        self.last_size </span><span>=</span><span style="color:#cccccc;"> size;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> Rect { width, height, </span><span>.. </span><span style="color:#cccccc;">} </span><span>=</span><span style="color:#cccccc;"> size;
</span><span style="color:#cccccc;">        </span><span style="background-color:#171717;color:#616161;">// double the height because each screen row has two rows of half block pixels
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> height </span><span>=</span><span style="color:#cccccc;"> height </span><span>* </span><span style="color:#eddd5a;">2</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        self.colors.</span><span style="color:#8aa6c1;">clear</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">        </span><span>use </span><span style="color:#cccccc;">rand::Rng;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> rng </span><span>= </span><span style="color:#cccccc;">rand::thread_rng();
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">for</span><span style="color:#cccccc;"> y </span><span>in </span><span style="color:#eddd5a;">0</span><span>..</span><span style="color:#cccccc;">height {
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> row </span><span>= </span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">::new();
</span><span style="color:#cccccc;">            </span><span style="background-color:#171717;color:#616161;">// more randomness towards the bottom
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> randomness_factor </span><span>= </span><span style="color:#cccccc;">(height </span><span>-</span><span style="color:#cccccc;"> y) </span><span>as </span><span style="color:#80d500;">f32 </span><span>/</span><span style="color:#cccccc;"> height </span><span>as </span><span style="color:#80d500;">f32</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">for </span><span>_ in </span><span style="color:#eddd5a;">0</span><span>..</span><span style="color:#cccccc;">width {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> base_value </span><span>=</span><span style="color:#cccccc;"> randomness_factor </span><span>* </span><span style="color:#cccccc;">((height </span><span>-</span><span style="color:#cccccc;"> y) </span><span>as </span><span style="color:#80d500;">f32 </span><span>/</span><span style="color:#cccccc;"> height </span><span>as </span><span style="color:#80d500;">f32</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">                </span><span style="background-color:#171717;color:#616161;">// adjust the range as needed
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> random_offset: </span><span style="color:#80d500;">f32 </span><span>=</span><span style="color:#cccccc;"> rng.</span><span style="color:#8aa6c1;">gen_range</span><span style="color:#cccccc;">(</span><span>-</span><span style="color:#eddd5a;">0.1</span><span>..</span><span style="color:#eddd5a;">0.1</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> value </span><span>=</span><span style="color:#cccccc;"> base_value </span><span>+</span><span style="color:#cccccc;"> random_offset;
</span><span style="color:#cccccc;">                </span><span style="background-color:#171717;color:#616161;">// clamp the value to ensure it stays within the valid range [0.0, 1.0]
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> value </span><span>=</span><span style="color:#cccccc;"> value.</span><span style="color:#8aa6c1;">max</span><span style="color:#cccccc;">(</span><span style="color:#eddd5a;">0.0</span><span style="color:#cccccc;">).</span><span style="color:#8aa6c1;">min</span><span style="color:#cccccc;">(</span><span style="color:#eddd5a;">1.0</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">                </span><span style="background-color:#171717;color:#616161;">// set hue to 0 for grayscale
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color </span><span>= </span><span style="color:#cccccc;">Hsv::new(</span><span style="color:#eddd5a;">0.0</span><span style="color:#cccccc;">, </span><span style="color:#eddd5a;">0.0</span><span style="color:#cccccc;">, value);
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color </span><span>= </span><span style="color:#cccccc;">Srgb::&lt;</span><span style="color:#80d500;">f32</span><span style="color:#cccccc;">&gt;::from_color_unclamped(color);
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color: Srgb&lt;</span><span style="color:#80d500;">u8</span><span style="color:#cccccc;">&gt; </span><span>=</span><span style="color:#cccccc;"> color.</span><span style="color:#8aa6c1;">into_format</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color </span><span>= </span><span style="color:#cccccc;">Color::Rgb(color.red, color.green, color.blue);
</span><span style="color:#cccccc;">                row.</span><span style="color:#8aa6c1;">push</span><span style="color:#cccccc;">(color);
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">            self.colors.</span><span style="color:#8aa6c1;">push</span><span style="color:#cccccc;">(row);
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>init_terminal</span><span style="color:#cccccc;">&lt;W&gt;(</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">stream</span><span style="color:#cccccc;">: W) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;Terminal&lt;CrosstermBackend&lt;W&gt;&gt;&gt;
</span><span>where
</span><span style="color:#cccccc;">    W: Write,
</span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">enable_raw_mode</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    stream.</span><span style="color:#8aa6c1;">execute</span><span style="color:#cccccc;">(EnterAlternateScreen)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(stream))</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    terminal.</span><span style="color:#8aa6c1;">clear</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    terminal.</span><span style="color:#8aa6c1;">hide_cursor</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(terminal)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>restore_terminal</span><span style="color:#cccccc;">&lt;W&gt;(</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">stream</span><span style="color:#cccccc;">: W) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt;
</span><span>where
</span><span style="color:#cccccc;">    W: Write,
</span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">disable_raw_mode</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    stream.</span><span style="color:#8aa6c1;">execute</span><span style="color:#cccccc;">(LeaveAlternateScreen)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> io_stream </span><span>= </span><span style="color:#cccccc;">IoStream::Stderr;
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">loop </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">match</span><span style="color:#cccccc;"> io_stream {
</span><span style="color:#cccccc;">            IoStream::Stdout </span><span>=&gt; </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">                io_stream </span><span>= </span><span style="color:#cccccc;">IoStream::Stderr;
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">            IoStream::Stderr </span><span>=&gt; </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">                io_stream </span><span>= </span><span style="color:#cccccc;">IoStream::Stdout;
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">        };
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if </span><span style="color:#cccccc;">App::run(io_stream)</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">break</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
</details>
<p>Press <em>space</em> to switch between stdout and stderr:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/stdout-vs-stderr.gif" alt="stdout vs stderr" /></p>
<p>Did you notice the FPS drop? stdout is <g>~2x faster</g> than stderr on a 550x360 terminal!</p>
<hr />
<h2 id="profiling"><g>Profiling</g></h2>
<p>Before diving into the Rust code, let's take a look at the runtime externally via observing the CPU and system calls to understand what is going on.</p>
<p>For this task I will use a profiling tool called <a href="https://github.com/mstange/samply"><strong>samply</strong></a>.</p>
<blockquote>
<p><code>samply</code> is a command line CPU profiler which uses the <a href="https://profiler.firefox.com/">Firefox Profiler</a> as its UI.</p>
</blockquote>
<p>It records a profile of the given command's execution and then opens <a href="https://profiler.firefox.com">profiler.firefox.com</a> in the browser where we can inspect a bunch of stuff like which functions were running for how long, flame graphs and timelines. We can even see the <em>source code</em> for the calls and which lines were sampled how many times.</p>
<p>Let's start by installing <code>samply</code>:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ cargo install samply
</span></code></pre>
<p>(I recently packaged it for Arch Linux so it is also available via <code>pacman -S samply</code> btw)</p>
<p>And then we need to make some changes to the code that we are going to profile. For Rust projects, it is <a href="https://github.com/mstange/samply#turn-on-debug-info-for-full-stacks">recommended</a> that we build in <em>release mode with debug info</em> for getting inline stacks and source code view. So we can add the following profile to our <code>Cargo.toml</code>:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">[profile.profiling]
</span><span style="color:#cccccc;">inherits = </span><span style="color:#ffd700;">&quot;release&quot;
</span><span style="color:#cccccc;">debug = true
</span></code></pre>
<p>Also, I made some changes to the previous <code>stdout-vs-stderr.rs</code>:</p>
<ul>
<li>Removed the parts such as FPS widget which are irrelevant for profiling.</li>
<li>Added <code>STREAM</code> environment variable for starting the TUI with the specified I/O stream.
<ul>
<li>Accepts either "stdout" or "stderr"</li>
</ul>
</li>
<li>Added <code>DURATION</code> environment variable for exiting the TUI after a certain number of seconds.</li>
</ul>
<details>
<summary><span class="glowy-code"><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/stdout-vs-stderr-profiler.rs">stdout-vs-stderr-profiler.rs</a></span> (<b>click here to expand</b>)</summary>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#!/</span><span style="color:#cccccc;">usr</span><span>/</span><span style="color:#cccccc;">bin</span><span>/</span><span style="color:#cccccc;">env rust</span><span>-</span><span style="color:#cccccc;">script
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">//! ```cargo
</span><span style="background-color:#171717;color:#616161;">//! [dependencies]
</span><span style="background-color:#171717;color:#616161;">//! anyhow = &quot;1.0.76&quot;
</span><span style="background-color:#171717;color:#616161;">//! crossterm = &quot;0.27.0&quot;
</span><span style="background-color:#171717;color:#616161;">//! palette = &quot;0.7.3&quot;
</span><span style="background-color:#171717;color:#616161;">//! rand = &quot;0.8.5&quot;
</span><span style="background-color:#171717;color:#616161;">//! ratatui = &quot;0.25.0&quot;
</span><span style="background-color:#171717;color:#616161;">//! ```
</span><span style="background-color:#171717;color:#616161;">//!
</span><span style="color:#cccccc;">
</span><span>use </span><span style="color:#cccccc;">anyhow::Result;
</span><span>use </span><span style="color:#cccccc;">std::{
</span><span style="color:#cccccc;">    env,
</span><span style="color:#cccccc;">    io::{stderr, stdout, Write},
</span><span style="color:#cccccc;">    time::{Duration, Instant},
</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span>use </span><span style="color:#cccccc;">crossterm::{
</span><span style="color:#cccccc;">    event::{self, Event, KeyCode, KeyEventKind},
</span><span style="color:#cccccc;">    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
</span><span style="color:#cccccc;">    ExecutableCommand,
</span><span style="color:#cccccc;">};
</span><span>use </span><span style="color:#cccccc;">palette::{convert::FromColorUnclamped, Hsv, Srgb};
</span><span>use </span><span style="color:#cccccc;">ratatui::{prelude::</span><span>*</span><span style="color:#cccccc;">, widgets::</span><span>*</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">#[derive(Copy, Clone, Debug, Default)]
</span><span style="color:#80d500;">enum </span><span style="color:#cccccc;">IoStream {
</span><span style="color:#cccccc;">    #[default]
</span><span style="color:#cccccc;">    Stdout,
</span><span style="color:#cccccc;">    Stderr,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#8aa6c1;">From</span><span style="color:#cccccc;">&lt;</span><span style="color:#8aa6c1;">String</span><span style="color:#cccccc;">&gt; </span><span>for </span><span style="color:#cccccc;">IoStream {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>from</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">value</span><span style="color:#cccccc;">: String) -&gt; </span><span style="color:#80d500;">Self </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">match</span><span style="color:#cccccc;"> value.</span><span style="color:#8aa6c1;">to_lowercase</span><span style="color:#cccccc;">().</span><span style="color:#8aa6c1;">as_str</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">            </span><span style="color:#ffd700;">&quot;stdout&quot; </span><span>=&gt; </span><span style="color:#80d500;">Self</span><span style="color:#cccccc;">::Stdout,
</span><span style="color:#cccccc;">            </span><span style="color:#ffd700;">&quot;stderr&quot; </span><span>=&gt; </span><span style="color:#80d500;">Self</span><span style="color:#cccccc;">::Stderr,
</span><span style="color:#cccccc;">            </span><span>_ =&gt; </span><span style="color:#80d500;">Self</span><span style="color:#cccccc;">::default(),
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">RgbColorsWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">/// The colors to render - should be double the height of the area
</span><span style="color:#cccccc;">    colors: </span><span>&amp;</span><span style="color:#80d500;">&#39;a </span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;</span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;Color&gt;&gt;,
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">/// the number of elapsed frames that have passed - used to animate the colors
</span><span style="color:#cccccc;">    frame_count: </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">Widget </span><span>for </span><span style="color:#cccccc;">RgbColorsWidget&lt;&#39;</span><span>_</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>render</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">area</span><span style="color:#cccccc;">: Rect, </span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">mut</span><span style="color:#cccccc;"> Buffer) {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> colors </span><span>= </span><span style="color:#cccccc;">self.colors;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">for </span><span style="color:#cccccc;">(xi, x) </span><span>in </span><span style="color:#cccccc;">(area.</span><span style="color:#8aa6c1;">left</span><span style="color:#cccccc;">()</span><span>..</span><span style="color:#cccccc;">area.</span><span style="color:#8aa6c1;">right</span><span style="color:#cccccc;">()).</span><span style="color:#8aa6c1;">enumerate</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">            </span><span style="background-color:#171717;color:#616161;">// animate the colors by shifting the x index by the frame number
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> xi </span><span>= </span><span style="color:#cccccc;">(xi </span><span>+ </span><span style="color:#cccccc;">self.frame_count) </span><span>% </span><span style="color:#cccccc;">(area.width </span><span>as </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">for </span><span style="color:#cccccc;">(yi, y) </span><span>in </span><span style="color:#cccccc;">(area.</span><span style="color:#8aa6c1;">top</span><span style="color:#cccccc;">()</span><span>..</span><span style="color:#cccccc;">area.</span><span style="color:#8aa6c1;">bottom</span><span style="color:#cccccc;">()).</span><span style="color:#8aa6c1;">enumerate</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> fg </span><span>=</span><span style="color:#cccccc;"> colors[yi </span><span>* </span><span style="color:#eddd5a;">2</span><span style="color:#cccccc;">][xi];
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> bg </span><span>=</span><span style="color:#cccccc;"> colors[yi </span><span>* </span><span style="color:#eddd5a;">2 </span><span>+ </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">][xi];
</span><span style="color:#cccccc;">                buf.</span><span style="color:#8aa6c1;">get_mut</span><span style="color:#cccccc;">(x, y).</span><span style="color:#8aa6c1;">set_char</span><span style="color:#cccccc;">(</span><span style="color:#ffd700;">&#39;▀&#39;</span><span style="color:#cccccc;">).</span><span style="color:#8aa6c1;">set_fg</span><span style="color:#cccccc;">(fg).</span><span style="color:#8aa6c1;">set_bg</span><span style="color:#cccccc;">(bg);
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">AppWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    rgb_colors_widget: RgbColorsWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt;,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl</span><span style="color:#cccccc;">&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; AppWidget&lt;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>new</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">app</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">&#39;a</span><span style="color:#cccccc;"> App) -&gt; </span><span style="color:#80d500;">Self </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">Self </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            rgb_colors_widget: RgbColorsWidget {
</span><span style="color:#cccccc;">                colors: </span><span>&amp;</span><span style="color:#cccccc;">app.colors,
</span><span style="color:#cccccc;">                frame_count: app.frame_count,
</span><span style="color:#cccccc;">            },
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">Widget </span><span>for </span><span style="color:#cccccc;">AppWidget&lt;&#39;</span><span>_</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>render</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">area</span><span style="color:#cccccc;">: Rect, </span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">: </span><span>&amp;</span><span style="color:#80d500;">mut</span><span style="color:#cccccc;"> Buffer) {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> main_layout </span><span>= </span><span style="color:#cccccc;">Layout::default()
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">direction</span><span style="color:#cccccc;">(Direction::Vertical)
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">constraints</span><span style="color:#cccccc;">([Constraint::Length(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">), Constraint::Min(</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">)])
</span><span style="color:#cccccc;">            .</span><span style="color:#8aa6c1;">split</span><span style="color:#cccccc;">(area);
</span><span style="color:#cccccc;">        self.rgb_colors_widget.</span><span style="color:#8aa6c1;">render</span><span style="color:#cccccc;">(main_layout[</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">], buf);
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">#[derive(Debug, Default)]
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">App {
</span><span style="color:#cccccc;">    should_quit: </span><span style="color:#80d500;">bool</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// a 2d vec of the colors to render, calculated when the size changes as this is expensive
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// to calculate every frame
</span><span style="color:#cccccc;">    colors: </span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;</span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">&lt;Color&gt;&gt;,
</span><span style="color:#cccccc;">    last_size: Rect,
</span><span style="color:#cccccc;">    frame_count: </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl </span><span style="color:#cccccc;">App {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">pub fn </span><span>run</span><span style="color:#cccccc;">&lt;W&gt;(</span><span style="font-style:italic;color:#8aa6c1;">io_stream</span><span style="color:#cccccc;">: IoStream, </span><span style="font-style:italic;color:#8aa6c1;">stream</span><span style="color:#cccccc;">: W, </span><span style="font-style:italic;color:#8aa6c1;">exit_after</span><span style="color:#cccccc;">: Duration) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt;
</span><span style="color:#cccccc;">    </span><span>where
</span><span style="color:#cccccc;">        W: Write,
</span><span style="color:#cccccc;">    {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#8aa6c1;">init_terminal</span><span style="color:#cccccc;">(stream)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> app </span><span>= </span><span style="color:#80d500;">Self</span><span style="color:#cccccc;">::default();
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> start_time </span><span>= </span><span style="color:#cccccc;">Instant::now();
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">while </span><span>!</span><span style="color:#cccccc;">app.should_quit {
</span><span style="color:#cccccc;">            app.</span><span style="color:#8aa6c1;">tick</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">            terminal.</span><span style="color:#8aa6c1;">draw</span><span style="color:#cccccc;">(|</span><span style="font-style:italic;color:#8aa6c1;">frame</span><span style="color:#cccccc;">| {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> size </span><span>=</span><span style="color:#cccccc;"> frame.</span><span style="color:#8aa6c1;">size</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">                app.</span><span style="color:#8aa6c1;">setup_colors</span><span style="color:#cccccc;">(size);
</span><span style="color:#cccccc;">                frame.</span><span style="color:#8aa6c1;">render_widget</span><span style="color:#cccccc;">(AppWidget::new(</span><span>&amp;</span><span style="color:#cccccc;">app), size);
</span><span style="color:#cccccc;">            })</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">            app.</span><span style="color:#8aa6c1;">handle_events</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">if</span><span style="color:#cccccc;"> start_time.</span><span style="color:#8aa6c1;">elapsed</span><span style="color:#cccccc;">() </span><span>&gt;=</span><span style="color:#cccccc;"> exit_after {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">break</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">match</span><span style="color:#cccccc;"> io_stream {
</span><span style="color:#cccccc;">            IoStream::Stdout </span><span>=&gt; </span><span style="color:#8aa6c1;">restore_terminal</span><span style="color:#cccccc;">(</span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">())</span><span>?</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">            IoStream::Stderr </span><span>=&gt; </span><span style="color:#8aa6c1;">restore_terminal</span><span style="color:#cccccc;">(</span><span style="color:#8aa6c1;">stderr</span><span style="color:#cccccc;">())</span><span>?</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">        </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>tick</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">        self.frame_count </span><span>+= </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>handle_events</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if </span><span style="color:#cccccc;">event::poll(Duration::from_secs_f32(</span><span style="color:#eddd5a;">1.0 </span><span>/ </span><span style="color:#eddd5a;">60.0</span><span style="color:#cccccc;">))</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">if let </span><span style="color:#cccccc;">Event::Key(key) </span><span>= </span><span style="color:#cccccc;">event::read()</span><span>? </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">if</span><span style="color:#cccccc;"> key.kind </span><span>== </span><span style="color:#cccccc;">KeyEventKind::Press </span><span>&amp;&amp;</span><span style="color:#cccccc;"> key.code </span><span>== </span><span style="color:#cccccc;">KeyCode::Char(</span><span style="color:#ffd700;">&#39;q&#39;</span><span style="color:#cccccc;">) {
</span><span style="color:#cccccc;">                    self.should_quit </span><span>= </span><span style="color:#80d500;">true</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">                }
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">        </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>setup_colors</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">self</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">size</span><span style="color:#cccccc;">: Rect) {
</span><span style="color:#cccccc;">        </span><span style="background-color:#171717;color:#616161;">// only update the colors if the size has changed since the last time we rendered
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">if </span><span style="color:#cccccc;">self.last_size.width </span><span>==</span><span style="color:#cccccc;"> size.width </span><span>&amp;&amp; </span><span style="color:#cccccc;">self.last_size.height </span><span>==</span><span style="color:#cccccc;"> size.height {
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">return</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">        self.last_size </span><span>=</span><span style="color:#cccccc;"> size;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> Rect { width, height, </span><span>.. </span><span style="color:#cccccc;">} </span><span>=</span><span style="color:#cccccc;"> size;
</span><span style="color:#cccccc;">        </span><span style="background-color:#171717;color:#616161;">// double the height because each screen row has two rows of half block pixels
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> height </span><span>=</span><span style="color:#cccccc;"> height </span><span>* </span><span style="color:#eddd5a;">2</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        self.colors.</span><span style="color:#8aa6c1;">clear</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">        </span><span>use </span><span style="color:#cccccc;">rand::Rng;
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> rng </span><span>= </span><span style="color:#cccccc;">rand::thread_rng();
</span><span style="color:#cccccc;">        </span><span style="color:#80d500;">for</span><span style="color:#cccccc;"> y </span><span>in </span><span style="color:#eddd5a;">0</span><span>..</span><span style="color:#cccccc;">height {
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> row </span><span>= </span><span style="color:#8aa6c1;">Vec</span><span style="color:#cccccc;">::new();
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> randomness_factor </span><span>= </span><span style="color:#cccccc;">(height </span><span>-</span><span style="color:#cccccc;"> y) </span><span>as </span><span style="color:#80d500;">f32 </span><span>/</span><span style="color:#cccccc;"> height </span><span>as </span><span style="color:#80d500;">f32</span><span style="color:#cccccc;">; </span><span style="background-color:#171717;color:#616161;">// More randomness towards the bottom
</span><span style="color:#cccccc;">            </span><span style="color:#80d500;">for </span><span>_ in </span><span style="color:#eddd5a;">0</span><span>..</span><span style="color:#cccccc;">width {
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> base_value </span><span>=</span><span style="color:#cccccc;"> randomness_factor </span><span>* </span><span style="color:#cccccc;">((height </span><span>-</span><span style="color:#cccccc;"> y) </span><span>as </span><span style="color:#80d500;">f32 </span><span>/</span><span style="color:#cccccc;"> height </span><span>as </span><span style="color:#80d500;">f32</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> random_offset: </span><span style="color:#80d500;">f32 </span><span>=</span><span style="color:#cccccc;"> rng.</span><span style="color:#8aa6c1;">gen_range</span><span style="color:#cccccc;">(</span><span>-</span><span style="color:#eddd5a;">0.1</span><span>..</span><span style="color:#eddd5a;">0.1</span><span style="color:#cccccc;">); </span><span style="background-color:#171717;color:#616161;">// Adjust the range as needed
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> value </span><span>=</span><span style="color:#cccccc;"> base_value </span><span>+</span><span style="color:#cccccc;"> random_offset;
</span><span style="color:#cccccc;">                </span><span style="background-color:#171717;color:#616161;">// Clamp the value to ensure it stays within the valid range [0.0, 1.0]
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> value </span><span>=</span><span style="color:#cccccc;"> value.</span><span style="color:#8aa6c1;">max</span><span style="color:#cccccc;">(</span><span style="color:#eddd5a;">0.0</span><span style="color:#cccccc;">).</span><span style="color:#8aa6c1;">min</span><span style="color:#cccccc;">(</span><span style="color:#eddd5a;">1.0</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color </span><span>= </span><span style="color:#cccccc;">Hsv::new(</span><span style="color:#eddd5a;">0.0</span><span style="color:#cccccc;">, </span><span style="color:#eddd5a;">0.0</span><span style="color:#cccccc;">, value); </span><span style="background-color:#171717;color:#616161;">// Set hue to 0 for grayscale
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color </span><span>= </span><span style="color:#cccccc;">Srgb::&lt;</span><span style="color:#80d500;">f32</span><span style="color:#cccccc;">&gt;::from_color_unclamped(color);
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color: Srgb&lt;</span><span style="color:#80d500;">u8</span><span style="color:#cccccc;">&gt; </span><span>=</span><span style="color:#cccccc;"> color.</span><span style="color:#8aa6c1;">into_format</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">                </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> color </span><span>= </span><span style="color:#cccccc;">Color::Rgb(color.red, color.green, color.blue);
</span><span style="color:#cccccc;">                row.</span><span style="color:#8aa6c1;">push</span><span style="color:#cccccc;">(color);
</span><span style="color:#cccccc;">            }
</span><span style="color:#cccccc;">            self.colors.</span><span style="color:#8aa6c1;">push</span><span style="color:#cccccc;">(row);
</span><span style="color:#cccccc;">        }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>init_terminal</span><span style="color:#cccccc;">&lt;W&gt;(</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">stream</span><span style="color:#cccccc;">: W) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;Terminal&lt;CrosstermBackend&lt;W&gt;&gt;&gt;
</span><span>where
</span><span style="color:#cccccc;">    W: Write,
</span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">enable_raw_mode</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    stream.</span><span style="color:#8aa6c1;">execute</span><span style="color:#cccccc;">(EnterAlternateScreen)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(stream))</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    terminal.</span><span style="color:#8aa6c1;">clear</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    terminal.</span><span style="color:#8aa6c1;">hide_cursor</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(terminal)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>restore_terminal</span><span style="color:#cccccc;">&lt;W&gt;(</span><span style="color:#80d500;">mut </span><span style="font-style:italic;color:#8aa6c1;">stream</span><span style="color:#cccccc;">: W) -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt;
</span><span>where
</span><span style="color:#cccccc;">    W: Write,
</span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">disable_raw_mode</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    stream.</span><span style="color:#8aa6c1;">execute</span><span style="color:#cccccc;">(LeaveAlternateScreen)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> stream </span><span>= </span><span style="color:#cccccc;">env::var(</span><span style="color:#ffd700;">&quot;STREAM&quot;</span><span style="color:#cccccc;">).</span><span style="color:#8aa6c1;">map</span><span style="color:#cccccc;">(IoStream::from).</span><span style="color:#8aa6c1;">unwrap_or_default</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> duration </span><span>= </span><span style="color:#cccccc;">env::var(</span><span style="color:#ffd700;">&quot;DURATION&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">        .</span><span style="color:#8aa6c1;">ok</span><span style="color:#cccccc;">()
</span><span style="color:#cccccc;">        .</span><span style="color:#8aa6c1;">and_then</span><span style="color:#cccccc;">(|</span><span style="font-style:italic;color:#8aa6c1;">v</span><span style="color:#cccccc;">| v.parse::&lt;</span><span style="color:#80d500;">u64</span><span style="color:#cccccc;">&gt;().</span><span style="color:#8aa6c1;">ok</span><span style="color:#cccccc;">())
</span><span style="color:#cccccc;">        .</span><span style="color:#8aa6c1;">map</span><span style="color:#cccccc;">(Duration::from_secs)
</span><span style="color:#cccccc;">        .</span><span style="color:#8aa6c1;">unwrap_or_else</span><span style="color:#cccccc;">(|| Duration::from_secs(</span><span style="color:#eddd5a;">5</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">match</span><span style="color:#cccccc;"> stream {
</span><span style="color:#cccccc;">        IoStream::Stdout </span><span>=&gt; </span><span style="color:#cccccc;">App::run(stream, </span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">(), duration)</span><span>?</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">        IoStream::Stderr </span><span>=&gt; </span><span style="color:#cccccc;">App::run(stream, </span><span style="color:#8aa6c1;">stderr</span><span style="color:#cccccc;">(), duration)</span><span>?</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
</details>
<p>Now we can build the binary with the <code>profiling</code> profile:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ cargo build</span><span style="font-style:italic;color:#8aa6c1;"> --profile</span><span style="color:#cccccc;"> profiling
</span></code></pre>
<p>To record a profile, simply run <code>samply</code>:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ export STREAM=</span><span style="color:#ffd700;">&quot;stdout&quot;
</span><span style="color:#cccccc;">$ export DURATION=5
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">$ samply record target/profiling/stdout-vs-stderr-profiler
</span></code></pre>
<p>(Or you can use my <a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/run-profiler.sh"><code>run-profiler.sh</code></a> script which does everything for you.)</p>
<p>Once the TUI exits after 5 seconds, <code>samply</code> will greet us with profiler.firefox.com:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stdout-mainpage.png" alt="samply stdout main" /></p>
<p>After we do the same for stderr via STREAM="stderr", we can start comparing what went differently for the I/O streams.</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stderr-mainpage.png" alt="samply stderr main" /></p>
<p>These profiles are also available for online browsing if you want to experiment yourself:</p>
<ul>
<li><a href="https://share.firefox.dev/3NRB24I">stdout profiling</a> (<a href="https://blog.orhun.dev/stdout-vs-stderr/samply-stdout-profile.json">download as a file</a>)</li>
<li><a href="https://share.firefox.dev/3tHBSKt">stderr profiling</a> (<a href="https://blog.orhun.dev/stdout-vs-stderr/samply-stderr-profile.json">download as a file</a>)</li>
</ul>
<p>Right off the bat, you can see the difference on the CPU view (first one being stdout):</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stdout-cpu-view.png" alt="samply stdout cpu" /></p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stderr-cpu-view.png" alt="samply stderr cpu" /></p>
<p>stdout has 708 samples compared to stderr which has 3,315 which means stdout made <g>4x less calls</g> than stderr in the course of 5 seconds! We are definitely on to something.</p>
<p>Next, we can figure out the characteristics of the each call. It is safe to assume that there will be some <em>write calls</em> to the terminal for each render. We can zoom in on the CPU view to see the each render more clearly:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stdout-renders.png" alt="samply stdout renders" /></p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stderr-renders.png" alt="samply stderr renders" /></p>
<p>As you can see, stdout rendered <g>more frames</g> in the same timespan as stderr. Also, there are more lighter yellow spikes happening for stderr (on every render) compared to stdout (occasionally).</p>
<p>We will figure out what those spikes are shortly.</p>
<p>We can zoom in even more and take a look at the calls that have happened for each render:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stdout-write-all.png" alt="samply stdout write" /></p>
<center>
<p><code>&lt;&amp;std::io::stdio::Stdout as std::io::Write&gt;::write_all</code></p>
</center>
<details>
<summary><g>Full Stack Trace</g> (<b>click here to expand</b>)</summary>
<pre style="background-color:#191919;color:#ffffff;"><code><span>&lt;std::io::stdio::Stdout as std::io::Write&gt;::write_all [library/std/src/io/stdio.rs]
</span><span>std::io::impls::&lt;impl std::io::Write for &amp;mut W&gt;::write_all [library/std/src/io/impls.rs]
</span><span>&lt;crossterm::command::write_command_ansi::Adapter&lt;T&gt; as core::fmt::Write&gt;::write_str [crossterm-0.27.0/src/command.rs]
</span><span>core::fmt::num::imp::fmt_u64 [library/core/src/fmt/num.rs]
</span><span>core::fmt::num::imp::&lt;impl core::fmt::Display for u8&gt;::fmt [library/core/src/fmt/num.rs]
</span><span>core::fmt::rt::Argument::fmt [library/core/src/fmt/rt.rs]
</span><span>core::fmt::write [library/core/src/fmt/mod.rs]
</span><span>&lt;crossterm::style::types::colored::Colored as core::fmt::Display&gt;::fmt [crossterm-0.27.0/src/style/types/colored.rs]
</span><span>core::fmt::rt::Argument::fmt [library/core/src/fmt/rt.rs]
</span><span>core::fmt::write [library/core/src/fmt/mod.rs]
</span><span>&lt;&amp;mut W as core::fmt::Write::write_fmt::SpecWriteFmt&gt;::spec_write_fmt [library/core/src/fmt/mod.rs]
</span><span>core::fmt::Write::write_fmt [library/core/src/fmt/mod.rs]
</span><span>&lt;crossterm::style::SetForegroundColor as crossterm::command::Command&gt;::write_ansi [crossterm-0.27.0/src/style.rs]
</span><span>crossterm::command::write_command_ansi [crossterm-0.27.0/src/command.rs]
</span><span>&lt;T as crossterm::command::QueueableCommand&gt;::queue [crossterm-0.27.0/src/command.rs]
</span><span>&lt;ratatui::backend::crossterm::CrosstermBackend&lt;W&gt; as ratatui::backend::Backend&gt;::draw::{{closure}} [ratatui-0.25.0/src/backend/crossterm.rs]
</span><span>core::result::Result&lt;T,E&gt;::and_then [library/core/src/result.rs]
</span><span>&lt;ratatui::backend::crossterm::CrosstermBackend&lt;W&gt; as ratatui::backend::Backend&gt;::draw [crossterm-0.27.0/src/macros.rs]
</span><span>ratatui::terminal::Terminal&lt;B&gt;::flush [ratatui-0.25.0/src/terminal.rs]
</span><span>ratatui::terminal::Terminal&lt;B&gt;::draw [ratatui-0.25.0/src/terminal.rs]
</span><span>stdout_vs_stderr::App::run [/home/orhun/gh/ratatui-stdout-vs-stderr/src/bin/2.rs]
</span><span>stdout_vs_stderr::main [/home/orhun/gh/ratatui-stdout-vs-stderr/src/bin/2.rs]
</span><span>core::ops::function::FnOnce::call_once [library/core/src/ops/function.rs]
</span><span>std::sys_common::backtrace::__rust_begin_short_backtrace [library/std/src/sys_common/backtrace.rs]
</span><span>std::rt::lang_start::{{closure}} [library/std/src/rt.rs]
</span><span>core::ops::function::impls::&lt;impl core::ops::function::FnOnce&lt;A&gt; for &amp;F&gt;::call_once [library/core/src/ops/function.rs]
</span><span>std::panicking::try::do_call [library/std/src/panicking.rs]
</span><span>std::panicking::try [library/std/src/panicking.rs]
</span><span>std::panic::catch_unwind [library/std/src/panic.rs]
</span><span>std::rt::lang_start_internal::{{closure}} [library/std/src/rt.rs]
</span><span>std::panicking::try::do_call [library/std/src/panicking.rs]
</span><span>std::panicking::try [library/std/src/panicking.rs]
</span><span>std::panic::catch_unwind [library/std/src/panic.rs]
</span><span>std::rt::lang_start_internal [library/std/src/rt.rs]
</span><span>std::rt::lang_start [library/std/src/rt.rs]
</span><span>_libc_start_call_main [/usr/src/debug/glibc/glibc/csu/../sysdeps/nptl/libc_start_call_main.h]
</span><span>_libc_start_main_impl [/usr/src/debug/glibc/glibc/csu/../csu/libc-start.c]
</span><span>start [stdout-vs-stderr]
</span><span>0x7fff18a00137
</span></code></pre>
</details>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stderr-write-all.png" alt="samply stderr write" /></p>
<center>
<p><code>&lt;std::io::stdio::StderrLock as std::io::Write&gt;::write_all</code></p>
</center>
<details>
<summary><g>Full Stack Trace</g> (<b>click here to expand</b>)</summary>
<pre style="background-color:#191919;color:#ffffff;"><code><span>&lt;std::io::stdio::StderrLock as std::io::Write&gt;::write_all [library/std/src/io/stdio.rs]
</span><span>&lt;&amp;std::io::stdio::Stderr as std::io::Write&gt;::write_all [library/std/src/io/stdio.rs]
</span><span>&lt;std::io::stdio::Stderr as std::io::Write&gt;::write_all [library/std/src/io/stdio.rs]
</span><span>std::io::impls::&lt;impl std::io::Write for &amp;mut W&gt;::write_all [library/std/src/io/impls.rs]
</span><span>&lt;crossterm::command::write_command_ansi::Adapter&lt;T&gt; as core::fmt::Write&gt;::write_str [crossterm-0.27.0/src/command.rs]
</span><span>core::fmt::write [library/core/src/fmt/mod.rs]
</span><span>&lt;crossterm::style::types::colored::Colored as core::fmt::Display&gt;::fmt [crossterm-0.27.0/src/style/types/colored.rs]
</span><span>core::fmt::rt::Argument::fmt [library/core/src/fmt/rt.rs]
</span><span>core::fmt::write [library/core/src/fmt/mod.rs]
</span><span>&lt;&amp;mut W as core::fmt::Write::write_fmt::SpecWriteFmt&gt;::spec_write_fmt [library/core/src/fmt/mod.rs]
</span><span>core::fmt::Write::write_fmt [library/core/src/fmt/mod.rs]
</span><span>&lt;crossterm::style::SetForegroundColor as crossterm::command::Command&gt;::write_ansi [crossterm-0.27.0/src/style.rs]
</span><span>crossterm::command::write_command_ansi [crossterm-0.27.0/src/command.rs]
</span><span>&lt;T as crossterm::command::QueueableCommand&gt;::queue [crossterm-0.27.0/src/command.rs]
</span><span>&lt;ratatui::backend::crossterm::CrosstermBackend&lt;W&gt; as ratatui::backend::Backend&gt;::draw::{{closure}} [ratatui-0.25.0/src/backend/crossterm.rs]
</span><span>core::result::Result&lt;T,E&gt;::and_then [library/core/src/result.rs]
</span><span>&lt;ratatui::backend::crossterm::CrosstermBackend&lt;W&gt; as ratatui::backend::Backend&gt;::draw [crossterm-0.27.0/src/macros.rs]
</span><span>ratatui::terminal::Terminal&lt;B&gt;::flush [ratatui-0.25.0/src/terminal.rs]
</span><span>ratatui::terminal::Terminal&lt;B&gt;::draw [ratatui-0.25.0/src/terminal.rs]
</span><span>stdout_vs_stderr::App::run [/home/orhun/gh/ratatui-stdout-vs-stderr/src/bin/2.rs]
</span><span>stdout_vs_stderr::main [/home/orhun/gh/ratatui-stdout-vs-stderr/src/bin/2.rs]
</span><span>core::ops::function::FnOnce::call_once [library/core/src/ops/function.rs]
</span><span>std::sys_common::backtrace::__rust_begin_short_backtrace [library/std/src/sys_common/backtrace.rs]
</span><span>std::rt::lang_start::{{closure}} [library/std/src/rt.rs]
</span><span>core::ops::function::impls::&lt;impl core::ops::function::FnOnce&lt;A&gt; for &amp;F&gt;::call_once [library/core/src/ops/function.rs]
</span><span>std::panicking::try::do_call [library/std/src/panicking.rs]
</span><span>std::panicking::try [library/std/src/panicking.rs]
</span><span>std::panic::catch_unwind [library/std/src/panic.rs]
</span><span>std::rt::lang_start_internal::{{closure}} [library/std/src/rt.rs]
</span><span>std::panicking::try::do_call [library/std/src/panicking.rs]
</span><span>std::panicking::try [library/std/src/panicking.rs]
</span><span>std::panic::catch_unwind [library/std/src/panic.rs]
</span><span>std::rt::lang_start_internal [library/std/src/rt.rs]
</span><span>std::rt::lang_start [library/std/src/rt.rs]
</span><span>_libc_start_call_main [/usr/src/debug/glibc/glibc/csu/../sysdeps/nptl/libc_start_call_main.h]
</span><span>_libc_start_main_impl [/usr/src/debug/glibc/glibc/csu/../csu/libc-start.c]
</span><span>start [stdout-vs-stderr]
</span><span>0x7ffe88c759d7
</span></code></pre>
</details>
<p><q>Now it makes sense, those spikes were <a href="https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all"><code>write_all</code></a> calls. It is nice to find that out, but what does that even mean?</q></p>
<p>It means that:</p>
<ul>
<li><strong>stdout</strong> called <code>write_all</code> <g>once in 5.2ms</g> and it happens every once in a while.</li>
<li><strong>stderr</strong> called <code>write_all</code> <g>5 times in 66ms</g> and it is called multiple times for almost every render.</li>
</ul>
<p>We can see this more clearly from the stack chart (first one being stdout):</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stdout-stack-chart.png" alt="samply stdout stack chart" /></p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stderr-stack-chart.png" alt="samply stderr stack chart" /></p>
<p>Lastly, we can check the code of this call but it is not really helpful since it is abstracted:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/samply-stderr-code-view.png" alt="samply stderr code view" /></p>
<p><q>So, what is the take away from all of this?</q></p>
<p>The conclusion is that stdout making less write calls thus able to render more frames in the same amount of time. In other words, stderr blocks until the write function for each frame is rendered to the terminal whereas stdout returns faster.</p>
<p>There must be some <g>buffering</g> happening for stdout.</p>
<hr />
<h2 id="testing-the-buffered-theory"><g>Testing the buffered theory</g></h2>
<p>Let's remember the change that we have made which led us to this point:</p>
<pre data-lang="diff" style="background-color:#191919;color:#ffffff;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="background-color:#420e09;color:#f8f8f8;">-let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stdout()))?;
</span><span style="background-color:#253b22;color:#f8f8f8;">+let mut terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
</span></code></pre>
<p>So, something <em>internal</em> changes when we do this. <code>ratatui</code>'s <a href="https://docs.rs/ratatui/latest/ratatui/backend/struct.CrosstermBackend.html"><code>CrosstermBackend</code></a> is a good place to look first:</p>
<blockquote>
<p>The <code>CrosstermBackend</code> struct is a wrapper around a writer implementing <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html"><code>Write</code></a>, which is used to send commands to the terminal. It provides methods for drawing content, manipulating the cursor, and clearing the terminal screen.</p>
</blockquote>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="background-color:#171717;color:#616161;">/// A Backend implementation that uses Crossterm to render to the terminal.
</span><span style="color:#80d500;">pub struct </span><span style="color:#cccccc;">CrosstermBackend&lt;W: Write&gt; {
</span><span style="color:#cccccc;">    writer: W,
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">impl</span><span style="color:#cccccc;">&lt;W&gt; CrosstermBackend&lt;W&gt;
</span><span>where
</span><span style="color:#cccccc;">    W: Write,
</span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">pub fn </span><span>new</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">writer</span><span style="color:#cccccc;">: W) -&gt; CrosstermBackend&lt;W&gt; {
</span><span style="color:#cccccc;">        CrosstermBackend { writer }
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span></code></pre>
<p><q><code>Write</code>?</q></p>
<p><a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html"><code>Write</code></a> is a Rust trait for objects that can be used for writing byte streams. It has methods such as <code>write</code>, <code>flush</code> and most importantly <code>write_all</code> which we encountered before. The code above means that <code>CrosstermBackend</code> can work with anything that implements <code>Write</code> such as <code>File</code>, <code>&amp;mut [8]</code> and other types including <code>Stdout</code>. This abstraction helps us to use the backend with different structs.</p>
<p>That's why the compiler is not complaining when we change the argument from <a href="https://doc.rust-lang.org/std/io/struct.Stdout.html"><code>Stdout</code></a> to <a href="https://doc.rust-lang.org/std/io/struct.Stderr.html"><code>Stderr</code></a>.</p>
<p><q>Okay so <code>ratatui</code> uses stdout as a writer and sends it to <code>crossterm</code> for writing. In this case, we need to go one layer deeper to <code>crossterm</code> to see what it is doing different for stdout and stderr.</p>
<p>Actually, no. Take a look at this diagram:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/ratatui-write-impl-diagram.png" alt="write impl diagram" /></p>
<p>As you go deeper, the capabilities of the passed type are constrained by the implementation. In other words, if you accept a parameter that is <code>Write</code>, you have only a set of functionality you can work with (<code>write</code>, <code>write_all</code>, etc.) In this case, <code>crossterm</code> does not have any chance to tell stdout from stderr to act different upon it, because it only knows about "a type" that is write.</p>
<p>That's why we need to go <em>shallower</em>, that being the point we started, <a href="https://doc.rust-lang.org/std/io/struct.Stdout.html">Stdout</a> and <a href="https://doc.rust-lang.org/std/io/struct.Stderr.html">Stderr</a> structs.</p>
<p><q>Wait, are you saying that we need to check out the source code of the Rust standard library to get an answer to this? Doesn't that mean that stdout is <em>not always faster</em> than stderr and it depends on the implementation details?</q></p>
<p>Exactly. "Everything is a file", remember? stdout and stderr are also files which are no different. Rust must be doing some magic in this case. 🪄</p>
<p>To find out the magic, we can take a look at the definition of <code>Stdout</code>:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">pub struct </span><span style="color:#cccccc;">Stdout {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// FIXME: this should be LineWriter or BufWriter depending on the state of
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">//        stdout (tty or not). Note that if this is not line buffered it
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">//        should also flush-on-panic or some form of flush-on-abort.
</span><span style="color:#cccccc;">    inner: </span><span>&amp;</span><span style="color:#80d500;">&#39;static </span><span style="color:#cccccc;">ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;,
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<p><a href="https://github.com/rust-lang/rust/blob/1.74.1/library/std/src/io/stdio.rs#L535-L540">std/src/io/stdio.rs#L535-L540</a></p>
</center>
<p>Now let's see <code>Stderr</code>:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">pub struct </span><span style="color:#cccccc;">Stderr {
</span><span style="color:#cccccc;">    inner: </span><span>&amp;</span><span style="color:#80d500;">&#39;static </span><span style="color:#cccccc;">ReentrantMutex&lt;RefCell&lt;StderrRaw&gt;&gt;,
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<p><a href="https://github.com/rust-lang/rust/blob/1.74.1/library/std/src/io/stdio.rs#L778-L780">std/src/io/stdio.rs#L778-L780</a></p>
</center>
<p>Take a look at the diff:</p>
<pre data-lang="diff" style="background-color:#191919;color:#ffffff;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="background-color:#420e09;color:#f8f8f8;">-ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;
</span><span style="background-color:#253b22;color:#f8f8f8;">+ReentrantMutex&lt;RefCell&lt;StderrRaw&gt;&gt;
</span></code></pre>
<p><q>Hmm... So <code>Stdout</code> is additionally wrapped in another struct called <code>LineWriter</code>.</q></p>
<p>Yes, do you see where this is going?</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/io/struct.LineWriter.html"><code>LineWriter</code></a> wraps a writer and buffers output to it,<br />
flushing whenever a newline (<code>0x0a</code>, <code>'\n'</code>) is detected.</p>
</blockquote>
<p><g>Bingo!</g></p>
<blockquote>
<p>We can use <a href="https://doc.rust-lang.org/std/io/struct.LineWriter.html"><code>LineWriter</code></a> to write one line at a time, significantly reducing the number of actual writes to the file.</p>
</blockquote>
<p>This is what we were looking for all along. Let's try it!</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::io::{self, LineWriter, Write};
</span><span>use </span><span style="color:#cccccc;">std::thread;
</span><span>use </span><span style="color:#cccccc;">std::time::Duration;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> stdout </span><span>= </span><span style="color:#cccccc;">io::stdout();
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> writer </span><span>= </span><span style="color:#cccccc;">LineWriter::new(stdout);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">write_all</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">b</span><span style="color:#ffd700;">&quot;In Rust&#39;s domain where choices gleam,&quot;</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">eprintln!(</span><span style="color:#ffd700;">&quot;[waiting for newline]&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">thread::sleep(Duration::from_secs(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// No bytes are written until a newline is encountered
</span><span style="background-color:#171717;color:#616161;">// (or the internal buffer is filled).
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">write_all</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">b</span><span style="color:#ffd700;">&quot;</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">eprintln!(</span><span style="color:#ffd700;">&quot;</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">[writing the rest]&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">thread::sleep(Duration::from_secs(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// Write the rest.
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">write_all</span><span style="color:#cccccc;">(
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">b</span><span style="color:#ffd700;">&quot;Ratatui&#39;s path, a unique stream.
</span><span style="color:#ffd700;">Terminal canvas, colors bright,
</span><span style="color:#ffd700;">Untraveled road, a different light.
</span><span style="color:#ffd700;">That choice, the difference, in code&#39;s delight.&quot;</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// The last line doesn&#39;t end in a newline,
</span><span style="background-color:#171717;color:#616161;">// so we have to flush or drop the `LineWriter` to finish writing.
</span><span style="color:#cccccc;">eprintln!(</span><span style="color:#ffd700;">&quot;</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">[flush or drop to finish writing]&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">thread::sleep(Duration::from_secs(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">flush</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span></code></pre>
<center>
<span class="glowy-code">
<p><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/writer/linewriter.rs">linewriter.rs</a></p>
</span>
</center>
<p>If we run this code:</p>
<pre style="background-color:#191919;color:#ffffff;"><code><span>[waiting for newline]
</span><span>In Rust&#39;s domain where choices gleam,
</span><span>
</span><span>[writing the rest]
</span><span>Ratatui&#39;s path, a unique stream.
</span><span>Terminal canvas, colors bright,
</span><span>Untraveled road, a different light.
</span><span>
</span><span>[flush or drop to finish writing]
</span><span>That choice, the difference, in code&#39;s delight.
</span></code></pre>
<p>From this output, we can observe:</p>
<ul>
<li>First <code>eprintln!</code> message is printed and the writer waits for newline character to write to stdout (even though we already called <code>write_all</code> before).</li>
<li>The second part of the poem is printed as a whole until the last line.</li>
<li>Last line is not being printed until we flush the stdout.</li>
</ul>
<p>Although this might seem like a pretty weird behavior at first glance, it actually has a huge performance benefit and it is the reason why stdout is <em>much faster</em> than stderr!</p>
<p>See you in another blog pos-</p>
<p><q>Wait! Is that it?</q></p>
<p>You're right, we can actually do more with this information.</p>
<hr />
<h2 id="experimenting-with-buffered-writes"><g>Experimenting with buffered writes</g></h2>
<p>Let's go back to the standard library definition of <code>Stdout</code>:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">pub struct </span><span style="color:#cccccc;">Stdout {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// FIXME: this should be LineWriter or BufWriter depending on the state of
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">//        stdout (tty or not). Note that if this is not line buffered it
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">//        should also flush-on-panic or some form of flush-on-abort.
</span><span style="color:#cccccc;">    inner: </span><span>&amp;</span><span style="color:#80d500;">&#39;static </span><span style="color:#cccccc;">ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;,
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<p><a href="https://github.com/rust-lang/rust/blob/1.74.1/library/std/src/io/stdio.rs#L535-L540">std/src/io/stdio.rs#L535-L540</a></p>
</center>
<p><q>Yeah, what's up with that <code>FIXME</code> comment there? Also, what is <code>BufWriter</code>?</q></p>
<p>Good questions, the documentation explains <a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html">BufWriter</a> very well:</p>
<blockquote>
<p>A <code>BufWriter</code> keeps an in-memory buffer of data and writes it to an underlying writer in large, infrequent batches.
<code>BufWriter</code> can improve the speed of programs that make <em>small</em> and <em>repeated</em> write calls to the same file or network socket.</p>
</blockquote>
<p>In other words, <code>BufWriter</code> writes data to its internal buffer instead of the actual stream and then infrequently writes this collected data to the stream.</p>
<p><q>Isn't that the same thing as <code>LineWriter</code>?</q></p>
<p>Good point! They actually have a distinction when it comes to flushing (i.e. when the buffered data is written to the stream).</p>
<ul>
<li><code>BufWriter</code>: flushes when the internal buffer is full.</li>
<li><code>LineWriter</code>: same behavior as <code>BufWriter</code> but also flushes for each line (when <code>0x0a</code> or <code>\n</code> is detected).</li>
</ul>
<p>Also, they both flush when the writer goes out of scope.</p>
<p>To make it more clear:</p>
<center>
<img alt="BufWriter vs LineWriter" src="bufwriter-vs-linewriter.png" style="width: 80%"/>
</center>
<p>Let's change our previous <code>LineWriter</code> example to use <code>BufWriter</code>:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::io::{self, BufWriter, Write};
</span><span>use </span><span style="color:#cccccc;">std::thread;
</span><span>use </span><span style="color:#cccccc;">std::time::Duration;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> stdout </span><span>= </span><span style="color:#cccccc;">io::stdout();
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> writer </span><span>= </span><span style="color:#cccccc;">BufWriter::new(stdout);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">write_all</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">b</span><span style="color:#ffd700;">&quot;In Rust&#39;s domain where choices gleam,&quot;</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">eprintln!(</span><span style="color:#ffd700;">&quot;[writing the first line]&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">thread::sleep(Duration::from_secs(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// No bytes are written until a newline is encountered
</span><span style="background-color:#171717;color:#616161;">// (or the internal buffer is filled).
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">write_all</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">b</span><span style="color:#ffd700;">&quot;</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">eprintln!(</span><span style="color:#ffd700;">&quot;</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">[writing the rest]&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">thread::sleep(Duration::from_secs(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// Write the rest.
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">write_all</span><span style="color:#cccccc;">(
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">b</span><span style="color:#ffd700;">&quot;Ratatui&#39;s path, a unique stream.
</span><span style="color:#ffd700;">Terminal canvas, colors bright,
</span><span style="color:#ffd700;">Untraveled road, a different light.
</span><span style="color:#ffd700;">That choice, the difference, in code&#39;s delight.&quot;</span><span style="color:#cccccc;">,
</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// The last line doesn&#39;t end in a newline,
</span><span style="background-color:#171717;color:#616161;">// so we have to flush or drop the `LineWriter` to finish writing.
</span><span style="color:#cccccc;">eprintln!(</span><span style="color:#ffd700;">&quot;</span><span style="font-weight:bold;color:#ff2837;">\n</span><span style="color:#ffd700;">[flush or drop to finish writing]&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">thread::sleep(Duration::from_secs(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">writer.</span><span style="color:#8aa6c1;">flush</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span></code></pre>
<center>
<span class="glowy-code">
<p><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/writer/bufwriter.rs">bufwriter.rs</a></p>
</span>
</center>
<p>We will see that nothing is printed until we flush the <code>BufWriter</code>:</p>
<pre style="background-color:#191919;color:#ffffff;"><code><span>[writing the first line]
</span><span>
</span><span>[writing the rest]
</span><span>
</span><span>[flush or drop to finish writing]
</span><span>In Rust&#39;s domain where choices gleam,
</span><span>Ratatui&#39;s path, a unique stream.
</span><span>Terminal canvas, colors bright,
</span><span>Untraveled road, a different light.
</span><span>That choice, the difference, in code&#39;s delight.
</span></code></pre>
<p>When it comes to the comment on the stdout struct:</p>
<blockquote>
<p>This should be LineWriter or BufWriter depending on the state of stdout (tty or not).</p>
</blockquote>
<p>What is being said here is that stdout should automatically decide between <g>line buffering</g> (<code>LineWriter</code>) and <g>block buffering</g> (<code>BufWriter</code>) based on whether if it is attached to a TTY or not.</p>
<p>So stdout should no longer be <em>line buffered</em> when outputting to a non-terminal (like piping output to a file).</p>
<p><q>I didn't get it, what is the advantage of using <code>BufWriter</code> in this case?</q></p>
<p>In the case of a non-TTY, let's say writing to a file, this would mean that the output will be <em>block buffered</em> thus we won't be making system calls for each line. In other words, we won't be flushing continuously which is a huge performance benefit. This can save us from substantial overhead when working with larger files.</p>
<p>And this is actually implemented in Rust but the pull request is not merged: <a href="https://github.com/rust-lang/rust/pull/115652"><strong>#115652</strong></a></p>
<p>Also, it would be super nice have a way to opt-in for block buffering for stdout in the future. There is a related discussion here: <a href="https://github.com/rust-lang/rust/issues/60673"><strong>#60673</strong></a></p>
<p><q>What would be the benefit of that?</q></p>
<p>Check out this code for example:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">for</span><span style="color:#cccccc;"> i </span><span>in </span><span style="color:#eddd5a;">1</span><span>..</span><span style="color:#eddd5a;">1000000 </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, i);
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>Keep in mind that <code>println!</code> is writing to stdout and it is <em>line buffered</em> (i.e. uses <code>LineWriter</code>) as default. In other words, it flushes the terminal for each line and performs a system call!</p>
<p>Now take a look at this:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">let</span><span style="color:#cccccc;"> stdout </span><span>= </span><span style="color:#cccccc;">io::stdout();
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> output </span><span>= </span><span style="color:#cccccc;">BufWriter::new(stdout);
</span><span style="color:#80d500;">for</span><span style="color:#cccccc;"> i </span><span>in </span><span style="color:#eddd5a;">1</span><span>..</span><span style="color:#eddd5a;">1000000 </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    writeln!(output, </span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, i)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>Here, we are wrapping stdout in a <code>BufWriter</code> which makes it <em>block buffered</em> ✨</p>
<details>
<summary><span class="glowy-code"><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/writer/block-buffered-stdout.rs">block-buffered-stdout.rs</a></span> (<b>click here to expand</b>)</summary>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#!/</span><span style="color:#cccccc;">usr</span><span>/</span><span style="color:#cccccc;">bin</span><span>/</span><span style="color:#cccccc;">env rust</span><span>-</span><span style="color:#cccccc;">script
</span><span style="color:#cccccc;">
</span><span>use </span><span style="color:#cccccc;">std::{
</span><span style="color:#cccccc;">    io::{self, BufWriter, </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">, Write},
</span><span style="color:#cccccc;">    time::Instant,
</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> first </span><span>= </span><span style="color:#cccccc;">Instant::now();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">for</span><span style="color:#cccccc;"> i </span><span>in </span><span style="color:#eddd5a;">1</span><span>..</span><span style="color:#eddd5a;">1000000 </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        println!(</span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, i);
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> first_elapsed </span><span>=</span><span style="color:#cccccc;"> first.</span><span style="color:#8aa6c1;">elapsed</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> second </span><span>= </span><span style="color:#cccccc;">Instant::now();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> stdout </span><span>= </span><span style="color:#cccccc;">io::stdout();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> output </span><span>= </span><span style="color:#cccccc;">BufWriter::new(stdout);
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">for</span><span style="color:#cccccc;"> i </span><span>in </span><span style="color:#eddd5a;">1</span><span>..</span><span style="color:#eddd5a;">1000000 </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        writeln!(output, </span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, i)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> second_elapsed </span><span>=</span><span style="color:#cccccc;"> second.</span><span style="color:#8aa6c1;">elapsed</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">    output.</span><span style="color:#8aa6c1;">flush</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Line buffered: </span><span style="color:#66ccff;">{:?}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, first_elapsed);
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Block buffered: </span><span style="color:#66ccff;">{:?}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, second_elapsed);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
</details>
<p>When we run it:</p>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ chmod +x block-buffered-stdout.rs
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">$ ./block-buffered-stdout.rs
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;"># [...]
</span><span style="color:#cccccc;">Line buffered: 1.080789949s
</span><span style="color:#cccccc;">Block buffered: 408.105636ms
</span></code></pre>
<p>Block buffered stdout runs <g>~2x faster</g>!</p>
<p><q>Nice! I wonder what happens if we apply this to our TUI app.</q></p>
<p>We can try by doing this change:</p>
<pre data-lang="diff" style="background-color:#191919;color:#ffffff;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="background-color:#420e09;color:#f8f8f8;">-let mut terminal = Terminal::new(CrosstermBackend::new(stdout()))?;
</span><span style="background-color:#253b22;color:#f8f8f8;">+let mut terminal = Terminal::new(CrosstermBackend::new(BufWriter::new(stdout())))?;
</span></code></pre>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/block-buffered-stdout.gif" alt="block buffered stdout" /></p>
<p>Hmm, there isn't a noticeable increase in performance. What if we try something more substantial like using a <g>block buffered stderr</g>. The default stderr is not buffered, remember?</p>
<p><q>Yeah... Oh! I have a better idea. How about making the stderr line buffered? Stdout is also line buffered so are we going to get the same performance?</q></p>
<p>Yes, let's try that!</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="background-color:#171717;color:#616161;">// line buffered stdout (as default)
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(</span><span style="color:#8aa6c1;">stdout</span><span style="color:#cccccc;">()))</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// line buffered stderr
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(LineWriter::new(</span><span style="color:#8aa6c1;">stderr</span><span style="color:#cccccc;">())))</span><span>?</span><span style="color:#cccccc;">;
</span></code></pre>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/line-buffered-stderr.gif" alt="line buffered stderr" /></p>
<p><q>Damn, did we just make the performance of stderr identical to stdout just by making it line buffered?</q></p>
<p>Oh yeah, looks like it!</p>
<hr />
<h2 id="experimenting-with-raw-writes"><g>Experimenting with raw writes</q></h2>
<p>How about we do the opposite of what we have done so far and try to make stdout <em>unbuffered</em>. This would degrade the performance and we should probably get a result similar to using the default stderr. Let's prove our hypothesis!</p>
<p>If we take a look at our findings so far:</p>
<table><thead><tr><th><strong>I/O Stream</strong></th><th><strong>Buffering</strong></th></tr></thead><tbody>
<tr><td><code>std::io::stderr()</code></td><td>Unbuffered/raw</td></tr>
<tr><td><code>LineWriter&lt;std::io::stderr()&gt;</code></td><td>Line buffered</td></tr>
<tr><td><code>BufWriter&lt;std::io::stderr()&gt;</code></td><td>Block buffered</td></tr>
<tr><td><code>std::io::stdout()</code></td><td>Line buffered</td></tr>
<tr><td><center><glitched>???</span></glitched></td><td>Unbuffered/raw</td></tr>
</tbody></table>
<p>Since <code>stderr()</code> returns a raw stream as default (i.e. <code>StderrRaw</code>), it is easier to implement a buffering layer on top of it. However, <code>stdout()</code> function already returns a buffered stream so we need to somehow get a <em>raw</em> stream.</p>
<p>If you remember the contents of <code>Stdout</code>:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="background-color:#171717;color:#616161;">/// A handle to the global standard output stream of the current process.
</span><span style="color:#80d500;">pub struct </span><span style="color:#cccccc;">Stdout {
</span><span style="color:#cccccc;">    inner: </span><span>&amp;</span><span style="color:#80d500;">&#39;static </span><span style="color:#cccccc;">ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw&gt;&gt;&gt;,
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<p><a href="https://github.com/rust-lang/rust/blob/1.74.1/library/std/src/io/stdio.rs#L535-L540">std/src/io/stdio.rs#L535-L540</a></p>
</center>
<p>We need the <code>StdoutRaw</code> for an unbuffered stream rather than having it wrapped inside <code>LineWriter</code>. The type definition also confirms the unbuffered behavior:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="background-color:#171717;color:#616161;">/// A handle to a raw instance of the standard output stream of this process.
</span><span style="background-color:#171717;color:#616161;">///
</span><span style="background-color:#171717;color:#616161;">/// This handle is not synchronized or buffered in any fashion. Constructed via
</span><span style="background-color:#171717;color:#616161;">/// the `std::io::stdio::stdout_raw` function.
</span><span style="color:#80d500;">struct </span><span style="color:#cccccc;">StdoutRaw(stdio::Stdout);
</span></code></pre>
<center>
<p><a href="https://github.com/rust-lang/rust/blob/1.74.1/library/std/src/io/stdio.rs#L45-L49">std/src/io/stdio.rs#L45-L49</a></p>
</center>
<p>Nice. This comment leads us to <code>stdout_raw</code> function:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="background-color:#171717;color:#616161;">/// Constructs a new raw handle to the standard output stream of this process.
</span><span style="background-color:#171717;color:#616161;">///
</span><span style="background-color:#171717;color:#616161;">/// The returned handle has no external synchronization or buffering layered on
</span><span style="background-color:#171717;color:#616161;">/// top.
</span><span style="color:#80d500;">const fn </span><span>stdout_raw</span><span style="color:#cccccc;">() -&gt; StdoutRaw {
</span><span style="color:#cccccc;">    StdoutRaw(stdio::Stdout::new())
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<p><a href="https://github.com/rust-lang/rust/blob/1.74.1/library/std/src/io/stdio.rs#L69-L81">std/src/io/stdio.rs#L69-L81</a></p>
</center>
<p><q>Easy, we can just construct a raw stdout via calling <code>stdout_raw</code>!</q></p>
<p>Not really, that is a private function.</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cccccc;">std::io::stdio::stdout_raw();
</span><span style="color:#cccccc;">         </span><span>^^^^^  ----------</span><span style="color:#cccccc;"> function `stdout_raw` is not publicly re</span><span>-</span><span style="color:#cccccc;">exported
</span><span style="color:#cccccc;">         </span><span>|
</span><span style="color:#cccccc;">         private module
</span></code></pre>
<p>There is actually a tracking issue from 2019 about exposing raw stdout/stderr/stdin: <a href="https://github.com/rust-lang/rust/issues/58326">#58326</a></p>
<blockquote>
<p>Currently there is not easy/obvious way to get an unbuffered Stdout/err/in. The types do exist in stdio, however they are not public for reasons not noted.
For example these types would be useful for CLI applications that write a lot of data at once without it getting unnecessarily flushed.</p>
</blockquote>
<p>And sadly, there isn't still an easy/obvious way to get an unbuffered I/O streams as of now :(</p>
<p><glitched>But!</glitched></p>
<p>This issue gives us some hints about possible workarounds. One thing that is reiterated a couple of times in the issue is that we can use <a href="https://doc.rust-lang.org/std/os/fd/trait.FromRawFd.html"><code>from_raw_fd</code></a> on Linux as a workaround.</p>
<p><q>Let me guess, <code>from_raw_fd</code> takes a file descriptor and we are simply going to use the file descriptor of stdout (which is "1") to create an unbuffered stream.</q></p>
<p>Exactly!</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::fs::File;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#cccccc;">File::from_raw_fd(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">writeln!(raw_stdout, </span><span style="color:#ffd700;">&quot;test&quot;</span><span style="color:#cccccc;">);
</span></code></pre>
<p>But...</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cccccc;">error[</span><span style="color:#66ccff;">E0133</span><span style="color:#cccccc;">]: call to </span><span style="color:#80d500;">unsafe</span><span style="color:#cccccc;"> function is </span><span style="color:#80d500;">unsafe</span><span style="color:#cccccc;"> and requires </span><span style="color:#80d500;">unsafe</span><span style="color:#cccccc;"> function or block
</span><span style="color:#cccccc;">   </span><span>|
</span><span style="color:#eddd5a;">55 </span><span>|                 </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#cccccc;">File::from_raw_fd(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">   |                                  ^^^^^^^^^^^^^^^^^^^^ call to unsafe function
</span><span style="color:#cccccc;">   </span><span>|
</span><span style="color:#cccccc;">   </span><span>=</span><span style="color:#cccccc;"> note: consult the function</span><span style="color:#80d500;">&#39;s</span><span style="color:#cccccc;"> documentation </span><span style="color:#80d500;">for</span><span style="color:#cccccc;"> information on how to avoid undefined behavior
</span></code></pre>
<p>If we read the <a href="https://doc.rust-lang.org/std/os/fd/trait.FromRawFd.html">documentation</a> of <code>from_raw_fd</code>:</p>
<blockquote>
<p>Safety: The <code>fd</code> passed in must be an owned file descriptor; in particular, it must be open.</p>
</blockquote>
<p>There are more details to it (which I will cover in another blog post) but the moral of the story is, we need to put our code in a <code>unsafe</code> block like so:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::fs::File;
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// SAFETY: no other functions should call `from_raw_fd`, so there
</span><span style="background-color:#171717;color:#616161;">// is only one owner for the file descriptor.
</span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ File::from_raw_fd(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">) };
</span><span style="color:#cccccc;">writeln!(raw_stdout, </span><span style="color:#ffd700;">&quot;test&quot;</span><span style="color:#cccccc;">);
</span></code></pre>
<p>If you run it, you will see "test" on stdout. Yay! \o/</p>
<p>However, as mentioned briefly in the previous section, there is still a big problem with this code. Going back to the documentation of <code>from_raw_fd</code>:</p>
<blockquote>
<p>This function is typically used to <strong>consume ownership</strong> of the specified file descriptor. When used in this way, the returned object will take responsibility for <strong>closing it</strong> when the object goes out of scope.</p>
</blockquote>
<p>What this means is that <code>raw_stdout</code> variable takes ownership of the file descriptor and it will <em>close</em> the stdout when it goes out of scope. In other words, when the created <code>File</code> is dropped, stdout is closed.</p>
<p><q>RIP.</q></p>
<p>We can confirm this behavior with this code:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::fs::File;
</span><span>use </span><span style="color:#cccccc;">std::io::{</span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">, Write};
</span><span>use </span><span style="color:#cccccc;">std::os::fd::FromRawFd;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>print1</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ File::from_raw_fd(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">) };
</span><span style="color:#cccccc;">    writeln!(raw_stdout, </span><span style="color:#ffd700;">&quot;test1&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>print2</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ File::from_raw_fd(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">) };
</span><span style="color:#cccccc;">    writeln!(raw_stdout, </span><span style="color:#ffd700;">&quot;test2&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">print1</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">print2</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<span class="glowy-code">
<p><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/unbuffered/raw-stdout-broken.rs">raw-stdout-broken.rs</a></p>
</span>
</center>
<p>What you expect to see is "test1" and "test2", however, stdout is closed after we leave the first function. When we try to open it again, it will panic because of the safety rule (the <code>fd</code> passed in must be an owned file descriptor + it must be <strong>open</strong>).</p>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ ./raw-stdout-broken.rs
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">test1
</span><span style="color:#cccccc;">Error: Os { code: 9, kind: Uncategorized, message: </span><span style="color:#ffd700;">&quot;Bad file descriptor&quot; </span><span style="color:#cccccc;">}
</span></code></pre>
<p><q>That's bad. What do we do?</q></p>
<p>In our case, we want the open file to <em>live through</em> the entire program. Let's also assume that this is a TUI program and we have separate functions where passing the <code>raw_stdout</code> value around isn't possible.</p>
<p>Well, there is still one quick dirty workaround: lazily initialize stdout and make it globally available via <a href="https://docs.rs/lazy_static/latest/lazy_static/"><code>lazy_static</code></a> (or another crate such as <a href="https://docs.rs/once_cell/latest/once_cell/"><code>once_cell</code></a>):</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use </span><span style="color:#cccccc;">std::fs::File;
</span><span>use </span><span style="color:#cccccc;">std::io::{</span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">, Write};
</span><span>use </span><span style="color:#cccccc;">std::os::fd::FromRawFd;
</span><span>use </span><span style="color:#cccccc;">std::sync::Mutex;
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">lazy_static! {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">static ref </span><span style="color:#66ccff;">RAW_STDOUT</span><span style="color:#cccccc;">: Mutex&lt;File&gt; </span><span>= </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ Mutex::new(File::from_raw_fd(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">)) };
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>print1</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    writeln!(RAW_STDOUT.lock().unwrap(), </span><span style="color:#ffd700;">&quot;test1&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>print2</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    writeln!(RAW_STDOUT.lock().unwrap(), </span><span style="color:#ffd700;">&quot;test2&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">print1</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">print2</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<span class="glowy-code">
<p><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/unbuffered/raw-stdout-1.rs">raw-stdout-1.rs</a></p>
</span>
</center>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ ./raw-stdout-1.rs
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">test1
</span><span style="color:#cccccc;">test2
</span></code></pre>
<p><q>Okay okay, this is a bit too much. I mean lazy, static, mutex, locking etc... Don't we have a better way to handle this? Besides, you can't really construct any other stdout instances with this code.</q></p>
<p>Actually there is a better way. The documentation of <a href="https://doc.rust-lang.org/std/os/fd/trait.FromRawFd.html"><code>FromRawFd</code></a> gives us a hint:</p>
<blockquote>
<p>Consuming ownership is not strictly required. Use a <code>From&lt;OwnedFd&gt;::from</code> implementation for an API which strictly consumes ownership.</p>
</blockquote>
<p>Sounds like we can work around closing the stdout if we use <a href="https://doc.rust-lang.org/std/os/fd/struct.OwnedFd.html"><code>OwnedFd</code></a>.</p>
<blockquote>
<p>An owned file descriptor.
This closes the file descriptor on drop. It is guaranteed that nobody else will close the file descriptor.</p>
</blockquote>
<p>So we can create a ✨ <g>global unbuffered stdout that does not consume the ownership of the underlying file descriptor</g> ✨ like so:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">lazy_static::lazy_static;
</span><span>use </span><span style="color:#cccccc;">std::fs::File;
</span><span>use </span><span style="color:#cccccc;">std::io::{</span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">, Write};
</span><span>use </span><span style="color:#cccccc;">std::os::fd::{FromRawFd, OwnedFd};
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">lazy_static! {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">static ref </span><span style="color:#66ccff;">RAW_STDOUT_FD</span><span style="color:#cccccc;">: OwnedFd </span><span>= </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ OwnedFd::from_raw_fd(</span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">) };
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>print1</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#cccccc;">File::from(</span><span style="color:#66ccff;">RAW_STDOUT_FD</span><span style="color:#cccccc;">.</span><span style="color:#8aa6c1;">try_clone</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">    writeln!(raw_stdout, </span><span style="color:#ffd700;">&quot;test1&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>print2</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#cccccc;">File::from(</span><span style="color:#66ccff;">RAW_STDOUT_FD</span><span style="color:#cccccc;">.</span><span style="color:#8aa6c1;">try_clone</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">    writeln!(raw_stdout, </span><span style="color:#ffd700;">&quot;test2&quot;</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">print1</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">print2</span><span style="color:#cccccc;">()</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
<center>
<span class="glowy-code">
<p><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/unbuffered/raw-stdout-2.rs">raw-stdout-2.rs</a></p>
</span>
</center>
<pre data-lang="bash" style="background-color:#191919;color:#ffffff;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#cccccc;">$ ./raw-stdout-2.rs
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">test1
</span><span style="color:#cccccc;">test2
</span></code></pre>
<p>If we want a more elegant solution, we can go for <code>as_raw_fd</code> function of <code>Stdout</code> instead of using plain "1":</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">static ref </span><span style="color:#66ccff;">RAW_STDOUT_FD</span><span style="color:#cccccc;">: OwnedFd </span><span>= </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> stdout </span><span>= </span><span style="color:#cccccc;">std::io::stdout();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> raw_fd </span><span>=</span><span style="color:#cccccc;"> stdout.</span><span style="color:#8aa6c1;">as_raw_fd</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ OwnedFd::from_raw_fd(raw_fd) }
</span><span style="color:#cccccc;">};
</span></code></pre>
<p><q>All of this pain, why?</q></p>
<p>So that we can do this:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#80d500;">let</span><span style="color:#cccccc;"> stdout </span><span>= </span><span style="color:#cccccc;">std::io::stdout();
</span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> raw_fd </span><span>=</span><span style="color:#cccccc;"> stdout.</span><span style="color:#8aa6c1;">as_raw_fd</span><span style="color:#cccccc;">();
</span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> raw_stdout </span><span>= </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ File::from_raw_fd(raw_fd) };
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// initialize the terminal with raw/unbuffered stdout
</span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> terminal </span><span>= </span><span style="color:#cccccc;">Terminal::new(CrosstermBackend::new(BufWriter::new(raw_stdout)))</span><span>?</span><span style="color:#cccccc;">;
</span></code></pre>
<p><q>Yeah, I almost forgot we were doing TUI stuff. I think the original question was "Is raw stdout as slow as raw stderr?".</q></p>
<p>Yes, let's find that out:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/raw-stdout.gif" alt="raw stdout" /></p>
<p>And that concludes it, raw stdout has the <em>same</em> performance as raw stderr.</p>
<hr />
<h2 id="making-stdout-faster"><g>Making stdout faster</g></h2>
<p>All of the things we have done so far begs the question: <glitched>can we make stdout faster?</glitched></p>
<p>Well, we now know that the reason why stderr is slower than stdout is that it is not <em>buffered</em>. So can we somehow achieve a faster (more performant) I/O with stdout by doing something like "better buffering"?</p>
<p>One other thing we can do to achieve a better FPS is that reducing the <code>write</code> calls that are made. However, <code>crossterm</code>/<code>ratatui</code> is already doing some optimizations such as not rendering the cells that are not changed. Our issue is that the FPS counter example we are using has cells that are always changing so this optimization has no effect. On top of that, we set both background and foreground colors so each render essentially takes multiple <code>write</code> calls.</p>
<p>In the screencast below, I modified the <code>crossterm</code> backend of <code>ratatui</code> to highlight the cells that are not being changed between renders. You can clearly see from the number of red cells that we are not able skip a lot of <code>write</code> calls since mostly everything is changing on the terminal:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/stdout-highlighted.gif" alt="stdout highlighted" /></p>
<p>However this is not the case for most of the TUI applications and this optimization actually saves us from re-rendering the majority of the screen.</p>
<p>Another interesting thing to look at is the buffer size. We can observe the following with a smaller buffer size (100 bytes) and delay between renders:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/stdout-small-buffer.gif" alt="stdout small buffer" /></p>
<p>Whereas a bigger buffer renders bigger chunks:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/stdout-big-buffer.gif" alt="stdout big buffer" /></p>
<p>We won't see a big difference if we remove the sleep except if we use very small/big buffer then the FPS drops vastly. We can probably experiment with the buffer size to draw a single line for each render but I wasn't able to get a better FPS in my attempts.</p>
<p>One other thing to mention, there were <a href="https://github.com/ratatui-org/ratatui/pull/601">recent developments</a> on <code>ratatui</code> to achieve a better performance for rendering cells. However, this doesn't have a big impact on FPS but definitely an improvement for using less resources.</p>
<p>We can keep experimenting with the low level functions of <code>crossterm</code> / <code>ratatui</code> to further optimize things but I feel like that would be a better topic for the <strong>part 2</strong> of this post.</p>
<p>While writing this, I wasn't able to achieve a "faster stdout" so feel free to leave comments about your suggestions!</p>
<hr />
<h2 id="findings"><g>Findings</g></h2>
<p>Here is the <code>ratatui</code> + <code>crossterm</code> rendering comparison for stdout and stderr using unbuffered / line-buffered / block-buffered writes:</p>
<p><img src="https://blog.orhun.dev/stdout-vs-stderr/stdout-vs-stderr-detailed.gif" alt="stdout vs stderr detailed" /></p>
<center>
<span class="glowy-code">
<p><a href="https://github.com/orhun/rust-stdout-vs-stderr/blob/main/src/stdout-vs-stderr-all.rs">stdout-vs-stderr-all.rs</a></p>
</span>
</center>
<p>The takeaway from this is that I/O streams have similar performances when the same buffering technique is used. We can also say that <code>std::io::stdout()</code> is <g>faster</g> than <code>std::io::stderr()</code> because the use of line-buffered vs no buffering.</p>
<p>If you want to reproduce the same results, I used the following environment in my experiments:</p>
<ul>
<li>Backend: <a href="https://github.com/crossterm-rs/crossterm">crossterm</a></li>
<li>TUI/rendering: <a href="https://github.com/ratatui-org/ratatui">ratatui</a></li>
<li>Terminal: <a href="https://github.com/alacritty/alacritty">alacritty</a></li>
<li>CPU: AMD Ryzen 7 4700U with Radeon Graphics (8) @ 2.000GHz</li>
<li>GPU: AMD ATI Radeon RX Vega 6</li>
<li>RAM: 24GB</li>
</ul>
<p>I'm curious about how the results might change in different systems/terminals so feel free to share your findings below!</p>
<hr />
<h2 id="other-languages"><g>Other Languages</g></h2>
<p>What we have covered so far only applies to Rust so it would be interesting to take a look at what other programming languages are doing in terms of buffered I/O.</p>
<h3 id="go"><strong>Go</strong></h3>
<p><code>os.Stdout</code> is unbuffered <a href="https://github.com/golang/go/issues/36619">as default</a>. It is possible to make it buffered as follows:</p>
<pre data-lang="go" style="background-color:#191919;color:#ffffff;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#cccccc;">f </span><span>:= </span><span style="color:#cccccc;">bufio.NewWriter(os.Stdout)
</span><span style="color:#80d500;">defer </span><span style="color:#cccccc;">f.Flush()
</span></code></pre>
<p>I'm guessing same applies for <code>os.Stderr</code> as well.</p>
<h3 id="python"><strong>Python</strong></h3>
<p>When printing interactively, <code>sys.stdout</code> is line buffered. Otherwise, it is block buffered like regular text files. The <code>sys.stderr</code> is line buffered in both cases.</p>
<p>One cool thing about Python is that we can actually make both streams unbuffered by passing the <code>-u</code> option or setting the <a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONUNBUFFERED">PYTHONUNBUFFERED</a> environment variable.</p>
<h3 id="c"><strong>C</strong></h3>
<blockquote>
<p>Now brace yourself because this might come as a bit of a surprise to you: when you <code>printf()</code> or <code>fprintf()</code> or use any I/O functions like that, it does not normally work immediately. For the sake of efficiency, and to irritate you, the I/O on a <code>FILE*</code> stream is buffered away safely until certain conditions are met, and only then is the actual I/O performed.</p>
</blockquote>
<p>As you can already tell, the I/O streams are buffered as default. However, this is configurable via <code>setbuf()</code> or <code>setvbuf()</code> function:</p>
<pre data-lang="c" style="background-color:#191919;color:#ffffff;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#80d500;">#include </span><span style="color:#ffd700;">&lt;stdio.h&gt;
</span><span style="color:#80d500;">void </span><span>setbuf</span><span style="color:#cccccc;">(FILE </span><span>*</span><span style="font-style:italic;color:#8aa6c1;">stream</span><span style="color:#cccccc;">, </span><span style="color:#80d500;">char </span><span>*</span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">);
</span><span style="color:#80d500;">int </span><span>setvbuf</span><span style="color:#cccccc;">(FILE </span><span>*</span><span style="font-style:italic;color:#8aa6c1;">stream</span><span style="color:#cccccc;">, </span><span style="color:#80d500;">char </span><span>*</span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">, </span><span style="color:#80d500;">int </span><span style="font-style:italic;color:#8aa6c1;">mode</span><span style="color:#cccccc;">, </span><span style="color:#8aa6c1;">size_t </span><span style="font-style:italic;color:#8aa6c1;">size</span><span style="color:#cccccc;">);
</span></code></pre>
<p>For example, to turn off buffering for stdout:</p>
<pre data-lang="c" style="background-color:#191919;color:#ffffff;" class="language-c "><code class="language-c" data-lang="c"><span style="background-color:#171717;color:#616161;">// _IONBF: stream will be unbuffered.
</span><span style="color:#cccccc;">setvbuf(stdout, </span><span style="color:#80d500;">NULL</span><span style="color:#cccccc;">, _IONBF, </span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">);
</span></code></pre>
<p><a href="http://web.archive.org/web/20171126034853/http://beej.us/guide/bgc/output/html/multipage/setvbuf.html">This documentation</a> has a good explanation of the different buffering options and related examples.</p>
<p>Here is an example for line buffering:</p>
<pre data-lang="c" style="background-color:#191919;color:#ffffff;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#cccccc;">FILE </span><span>*</span><span style="color:#cccccc;">fp;
</span><span style="color:#80d500;">char</span><span style="color:#cccccc;"> lineBuf[</span><span style="color:#eddd5a;">1024</span><span style="color:#cccccc;">];
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">fp </span><span>= </span><span style="color:#8aa6c1;">fopen</span><span style="color:#cccccc;">(</span><span style="color:#ffd700;">&quot;somefile.txt&quot;</span><span style="color:#cccccc;">, </span><span style="color:#ffd700;">&quot;r&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">setvbuf(fp, lineBuf, _IOLBF, </span><span style="color:#eddd5a;">1024</span><span style="color:#cccccc;">);  </span><span style="background-color:#171717;color:#616161;">// set to line buffering
</span><span style="background-color:#171717;color:#616161;">// ...
</span><span style="color:#cccccc;">fclose(fp);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">fp </span><span>= </span><span style="color:#8aa6c1;">fopen</span><span style="color:#cccccc;">(</span><span style="color:#ffd700;">&quot;another.dat&quot;</span><span style="color:#cccccc;">, </span><span style="color:#ffd700;">&quot;rb&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">setbuf(fp, </span><span style="color:#80d500;">NULL</span><span style="color:#cccccc;">); </span><span style="background-color:#171717;color:#616161;">// set to unbuffered
</span><span style="background-color:#171717;color:#616161;">// ...
</span><span style="color:#cccccc;">fclose(fp);
</span></code></pre>
<h2 id="zig"><strong>Zig</strong></h2>
<p>The I/O streams are unbuffered. We can achieve buffered writes as follows:</p>
<pre data-lang="zig" style="background-color:#191919;color:#ffffff;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#80d500;">const</span><span style="color:#cccccc;"> std </span><span>= </span><span style="color:#80d500;">@import</span><span style="color:#cccccc;">(</span><span style="color:#ffd700;">&quot;std&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">pub fn </span><span>main</span><span style="color:#cccccc;">() </span><span>!</span><span style="color:#80d500;">void </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">const</span><span style="color:#cccccc;"> out </span><span>=</span><span style="color:#cccccc;"> std.io.getStdOut();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">var</span><span style="color:#cccccc;"> buf </span><span>=</span><span style="color:#cccccc;"> std.io.bufferedWriter(out.writer());
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Get the Writer interface from BufferedWriter
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">var</span><span style="color:#cccccc;"> w </span><span>=</span><span style="color:#cccccc;"> buf.writer();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">try</span><span style="color:#cccccc;"> w.print(</span><span style="color:#ffd700;">&quot;check out my Zig Bits series as well!&quot;</span><span style="color:#cccccc;">, .{});
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Don&#39;t forget to flush!
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">try</span><span style="color:#cccccc;"> buf.flush();
</span><span style="color:#cccccc;">}
</span></code></pre>
<h2 id="c-1"><strong>C++</strong></h2>
<p><code>std::cout</code> is buffered according to <a href="https://www.programmingincpp.com/flush-the-output-stream-buffer.html">this article</a>.</p>
<p>Couldn't find your favorite programming language on this list? Have something to add/fix?<br />
<a href="https://github.com/orhun/personal-blog">Feel free to contribute to this blog</a>! ⚡</p>
<hr />
<h2 id="conclusion"><g>Conclusion</g></h2>
<p>We have covered:</p>
<ul>
<li>How I/O streams work on Unix-like systems</li>
<li>How terminal user interfaces work</li>
<li>How to build terminal user interfaces using Rust (w/ <code>ratatui</code>/<code>crossterm</code>)</li>
<li>How to profile applications and observing system calls (w/ <code>samply</code>)</li>
<li>Buffering for I/O streams
<ul>
<li>Line buffering (<code>LineWriter</code>)</li>
<li>Block buffering (<code>BufWriter</code>)</li>
<li>No buffering (<code>from_raw_fd</code>)</li>
</ul>
</li>
<li>Rust compared to other programming languages</li>
<li>And other things that I probably forgot to put here!</li>
</ul>
<p>📂 The code snippets used in this post are available <a href="https://github.com/orhun/rust-stdout-vs-stderr"><g>in this repository</g></a>.</p>
<p>🎢 It was a wild ride and I learned a lot! I'm hoping that I was able to share at least one thing you didn't know before.</p>
<p>🤔 I might have skipped something very important or shared incomplete information. Feel free to comment below or <a href="https://github.com/orhun/personal-blog">contribute</a> your edits case you have caught something. This is the beauty of these blog posts!</p>
<p>👏 I would like to give special thanks to the fellow <code>ratatui</code> maintainer Dheepak Krishnamurthy (<a href="https://github.com/kdheepak/">@kdheepak</a>) for pioneering the first steps of this research <a href="https://github.com/ratatui-org/ratatui/discussions/579#discussioncomment-7345178">in this discussion</a> and took time to investigate this further with me! <em>Kudos</em>!</p>
<p>Hope you enjoyed!</p>
<p><glitched>ciao!</glitched></p>
<hr />
<p>💖 Liked this article? Want to sponsor my blog posts and have early access? Want to add your name/logo or company's badge here? Check out my <a href="https://github.com/sponsors/orhun">GitHub sponsorship tiers</a>!</p>

    </div>

    
        <footer>
            <hr>
            <p>
                
                    Published by Orhun Parmaksız
                
                
                    
                    in <a href="https://blog.orhun.dev/categories/rust/">Rust</a>
                
                
            </p>
            
            
            <div style="display: flex; justify-content: space-between; align-items: center">
              <div>
                <iframe
                  src="https://github.com/sponsors/orhun/button"
                  title="Sponsor @orhun"
                  height="35"
                  width="116"
                  style="border: 0"
                ></iframe>
                <a href="https://www.buymeacoffee.com/orhun" target="_blank"
                  ><img
                    src="https://cdn.buymeacoffee.com/buttons/v2/default-white.png"
                    alt="Buy Me A Coffee"
                    style="height: 40px !important; width: 150px !important"
                /></a>
              </div>
              <div>
                <applause-button
                  style="width: 50px; height: 50px"
                  url="https://blog.orhun.dev&#x2F;stdout-vs-stderr&#x2F;"
                  color="white"
                  multiclap="true"
                />
              </div>
              <div>
                <div style="width: auto; height: 39px">
                  <p style="margin: 0; color: #fff; font-style: italic">✨ Sponsored by:</p>
                </div>
                <a href="https://terminaltrove.com/" target="_blank"
                  ><img
                    src="/sponsors/terminal_trove.png"
                    alt="Terminal Trove"
                    style="height: 40px; width: auto"
                /></a>
                <a href="https://rawkode.academy/" target="_blank"
                  ><img
                    src="/sponsors/rawkode_academy.png"
                    alt="Rawkode Academy"
                    style="height: 40px; width: auto"
                /></a>
                <a href="https://malwation.com/" target="_blank"
                  ><img
                    src="/sponsors/malwation.svg"
                    alt="Malwation"
                    style="height: 40px; width: auto"
                /></a>
              </div>
            </div>
            <script src="https://utteranc.es/client.js"
                    repo="orhun/personal-blog"
                    issue-term="url"
                    label="comments"
                    theme="github-dark"
                    crossorigin="anonymous"
                    async>
            </script>
        </footer>
    
</article>


    </body>

</html>
